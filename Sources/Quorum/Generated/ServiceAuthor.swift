/**
 * This file has been autogenerated by LGNC assembler on 2018-10-12 12:31:55.785895.
 * All changes will be lost on next assembly.
 */

import Entita
import LGNC
import LGNCore
import LGNP
import NIO

public extension Services {
    public struct Author: Service {
        public static let port = 1711

        public struct Contracts {}

        public static let info: [String: String] = [
            "ElderName": "hudruk",
        ]

        public static let contractExecutorMap: [String: Executor] = [
            Contracts.Checkin.URI: Author.contractCheckin,
            Contracts.Ping.URI: Author.contractPing,
            Contracts.Signup.URI: Author.contractSignup,
            Contracts.Login.URI: Author.contractLogin,
            Contracts.InternalSignup.URI: Author.contractInternalSignup,
            Contracts.InternalLogin.URI: Author.contractInternalLogin,
            Contracts.Authenticate.URI: Author.contractAuthenticate,
        ]

        private static var contractCheckinCallback: Contracts.Checkin.Callback!
        private static var contractPingCallback: Contracts.Ping.Callback!
        private static var contractSignupCallback: Contracts.Signup.Callback!
        private static var contractLoginCallback: Contracts.Login.Callback!
        private static var contractInternalSignupCallback: Contracts.InternalSignup.Callback!
        private static var contractInternalLoginCallback: Contracts.InternalLogin.Callback!
        private static var contractAuthenticateCallback: Contracts.Authenticate.Callback!

        public static func guaranteeCheckinContract(_ callback: @escaping Contracts.Checkin.Callback) {
            self.contractCheckinCallback = callback
        }

        public static func guaranteeCheckinContract(_ callback: @escaping Contracts.Checkin.NonFutureCallback) {
            self.guaranteeCheckinContract { (request, requestInfo) -> EventLoopFuture<Contracts.Checkin.Response> in
                let promise: EventLoopPromise<Contracts.Checkin.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteePingContract(_ callback: @escaping Contracts.Ping.Callback) {
            self.contractPingCallback = callback
        }

        public static func guaranteePingContract(_ callback: @escaping Contracts.Ping.NonFutureCallback) {
            self.guaranteePingContract { (request, requestInfo) -> EventLoopFuture<Contracts.Ping.Response> in
                let promise: EventLoopPromise<Contracts.Ping.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteeSignupContract(_ callback: @escaping Contracts.Signup.Callback) {
            self.contractSignupCallback = callback
        }

        public static func guaranteeSignupContract(_ callback: @escaping Contracts.Signup.NonFutureCallback) {
            self.guaranteeSignupContract { (request, requestInfo) -> EventLoopFuture<Contracts.Signup.Response> in
                let promise: EventLoopPromise<Contracts.Signup.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteeLoginContract(_ callback: @escaping Contracts.Login.Callback) {
            self.contractLoginCallback = callback
        }

        public static func guaranteeLoginContract(_ callback: @escaping Contracts.Login.NonFutureCallback) {
            self.guaranteeLoginContract { (request, requestInfo) -> EventLoopFuture<Contracts.Login.Response> in
                let promise: EventLoopPromise<Contracts.Login.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteeInternalSignupContract(_ callback: @escaping Contracts.InternalSignup.Callback) {
            self.contractInternalSignupCallback = callback
        }

        public static func guaranteeInternalSignupContract(_ callback: @escaping Contracts.InternalSignup.NonFutureCallback) {
            self.guaranteeInternalSignupContract { (request, requestInfo) -> EventLoopFuture<Contracts.InternalSignup.Response> in
                let promise: EventLoopPromise<Contracts.InternalSignup.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteeInternalLoginContract(_ callback: @escaping Contracts.InternalLogin.Callback) {
            self.contractInternalLoginCallback = callback
        }

        public static func guaranteeInternalLoginContract(_ callback: @escaping Contracts.InternalLogin.NonFutureCallback) {
            self.guaranteeInternalLoginContract { (request, requestInfo) -> EventLoopFuture<Contracts.InternalLogin.Response> in
                let promise: EventLoopPromise<Contracts.InternalLogin.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func guaranteeAuthenticateContract(_ callback: @escaping Contracts.Authenticate.Callback) {
            self.contractAuthenticateCallback = callback
        }

        public static func guaranteeAuthenticateContract(_ callback: @escaping Contracts.Authenticate.NonFutureCallback) {
            self.guaranteeAuthenticateContract { (request, requestInfo) -> EventLoopFuture<Contracts.Authenticate.Response> in
                let promise: EventLoopPromise<Contracts.Authenticate.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func executeCheckinContract(
            at address: Address,
            with request: Contracts.Checkin.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Checkin.Response> {
            return Contracts.Checkin.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executePingContract(
            at address: Address,
            with request: Contracts.Ping.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Ping.Response> {
            return Contracts.Ping.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executeSignupContract(
            at address: Address,
            with request: Contracts.Signup.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Signup.Response> {
            return Contracts.Signup.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executeLoginContract(
            at address: Address,
            with request: Contracts.Login.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Login.Response> {
            return Contracts.Login.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executeInternalSignupContract(
            at address: Address,
            with request: Contracts.InternalSignup.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.InternalSignup.Response> {
            return Contracts.InternalSignup.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executeInternalLoginContract(
            at address: Address,
            with request: Contracts.InternalLogin.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.InternalLogin.Response> {
            return Contracts.InternalLogin.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        public static func executeAuthenticateContract(
            at address: Address,
            with request: Contracts.Authenticate.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Authenticate.Response> {
            return Contracts.Authenticate.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        private static func contractCheckin(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractCheckinCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Checkin'")
            }
            return callback(
                try Contracts.Checkin.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractPing(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractPingCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Ping'")
            }
            return callback(
                try Contracts.Ping.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractSignup(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractSignupCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Signup'")
            }
            return callback(
                try Contracts.Signup.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractLogin(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractLoginCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Login'")
            }
            return callback(
                try Contracts.Login.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractInternalSignup(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractInternalSignupCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'InternalSignup'")
            }
            return callback(
                try Contracts.InternalSignup.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractInternalLogin(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractInternalLoginCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'InternalLogin'")
            }
            return callback(
                try Contracts.InternalLogin.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        private static func contractAuthenticate(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractAuthenticateCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Authenticate'")
            }
            return callback(
                try Contracts.Authenticate.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        public static func validateContractCheckinFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Checkin.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Checkin.Request.validateName(callback)
        }

        public static func validateContractPingFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Ping.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Ping.Request.validateName(callback)
        }

        public static func validateContractSignupFieldEmail(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Signup.Request.CallbackValidatorEmailAllowedValues>.Callback
        ) {
            Contracts.Signup.Request.validateEmail(callback)
        }

        public static func validateContractInternalSignupFieldEmail(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.InternalSignup.Request.CallbackValidatorEmailAllowedValues>.Callback
        ) {
            Contracts.InternalSignup.Request.validateEmail(callback)
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractCheckinCallback == nil {
                LGNCore.log("Contract 'Checkin' is not guaranteed")
                result = false
            }

            if self.contractPingCallback == nil {
                LGNCore.log("Contract 'Ping' is not guaranteed")
                result = false
            }

            if self.contractSignupCallback == nil {
                LGNCore.log("Contract 'Signup' is not guaranteed")
                result = false
            }

            if self.contractLoginCallback == nil {
                LGNCore.log("Contract 'Login' is not guaranteed")
                result = false
            }

            if self.contractInternalSignupCallback == nil {
                LGNCore.log("Contract 'InternalSignup' is not guaranteed")
                result = false
            }

            if self.contractInternalLoginCallback == nil {
                LGNCore.log("Contract 'InternalLogin' is not guaranteed")
                result = false
            }

            if self.contractAuthenticateCallback == nil {
                LGNCore.log("Contract 'Authenticate' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Checkin": [
                "Request": Contracts.Checkin.Request.keyDictionary,
                "Response": Contracts.Checkin.Response.keyDictionary,
            ],
            "Ping": [
                "Request": Contracts.Ping.Request.keyDictionary,
                "Response": Contracts.Ping.Response.keyDictionary,
            ],
            "Signup": [
                "Request": Contracts.Signup.Request.keyDictionary,
                "Response": Contracts.Signup.Response.keyDictionary,
            ],
            "Login": [
                "Request": Contracts.Login.Request.keyDictionary,
                "Response": Contracts.Login.Response.keyDictionary,
            ],
            "InternalSignup": [
                "Request": Contracts.InternalSignup.Request.keyDictionary,
                "Response": Contracts.InternalSignup.Response.keyDictionary,
            ],
            "InternalLogin": [
                "Request": Contracts.InternalLogin.Request.keyDictionary,
                "Response": Contracts.InternalLogin.Response.keyDictionary,
            ],
            "Authenticate": [
                "Request": Contracts.Authenticate.Request.keyDictionary,
                "Response": Contracts.Authenticate.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Author.Contracts {
    public struct Checkin: Contract {
        public typealias ParentService = Services.Author
        public typealias Request = Services.Shared.CheckinRequest
        public typealias Response = Services.Shared.CheckinResponse

        public static let URI = "Checkin"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeCheckinContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeCheckinContract(callback)
        }
    }

    public struct Ping: Contract {
        public typealias ParentService = Services.Author
        public typealias Request = Services.Shared.PingRequest
        public typealias Response = Services.Shared.PingResponse

        public static let URI = "Ping"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteePingContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteePingContract(callback)
        }
    }

    public struct Signup: Contract {
        public typealias ParentService = Services.Author
        public typealias Request = Services.Shared.UserSignupRequest
        public typealias Response = Services.Shared.UserSignupResponse

        public static let URI = "Signup"
        public static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeSignupContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeSignupContract(callback)
        }
    }

    public struct Login: Contract {
        public typealias ParentService = Services.Author
        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "Login"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeLoginContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeLoginContract(callback)
        }
    }

    public struct InternalSignup: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.UserSignupResponse

        public static let URI = "InternalSignup"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeInternalSignupContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeInternalSignupContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorEmailAllowedValues: String, ValidatorErrorRepresentable {
                case UserWithGivenEmailAlreadyExists = "User with given email already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .UserWithGivenEmailAlreadyExists:
                        return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "email": "b",
                "password1": "c",
                "password2": "d",
                "sex": "e",
                "ip": "f",
                "userAgent": "g",
                "country": "h",
            ]

            public let email: String
            public let password1: String
            public let password2: String
            public let sex: String
            public let ip: String
            public let userAgent: String
            public let country: String

            private static var validatorEmailClosure: Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback?

            public required init(
                email: String,
                password1: String,
                password2: String,
                sex: String,
                ip: String,
                userAgent: String,
                country: String
            ) {
                self.email = email
                self.password1 = password1
                self.password2 = password2
                self.sex = sex
                self.ip = ip
                self.userAgent = userAgent
                self.country = country
            }

            public static func initWithValidation(from dictionary: Entita.Dict) throws -> Request {
                var errors: [String: [ValidatorError]] = [
                    "email": [],
                    "password1": [],
                    "password2": [],
                    "sex": [],
                    "ip": [],
                    "userAgent": [],
                    "country": [],
                ]

                var _email: String = String()
                do {
                    _email = try Request.extract(param: "email", from: dictionary)

                    if let error = Validation.Regexp(pattern: "^.+@.+\\..+$", message: "Invalid email format").validate(input: _email) {
                        errors["email"]?.append(error)
                    }

                    if let validatorEmailClosure = self.validatorEmailClosure {
                        if let error = Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>(callback: validatorEmailClosure).validate(input: _email) {
                            errors["email"]?.append(error)
                        }
                    }
                } catch Entita.E.ExtractError {
                    errors["email"]?.append(Validation.Error.MissingValue())
                }

                var _password1: String = String()
                do {
                    _password1 = try Request.extract(param: "password1", from: dictionary)

                    if let error = Validation.Length.Min(length: 6).validate(input: _password1) {
                        errors["password1"]?.append(error)
                    }

                    if let error = Validation.Length.Max(length: 64, message: "Password must be less than 64 characters long").validate(input: _password1) {
                        errors["password1"]?.append(error)
                    }
                } catch Entita.E.ExtractError {
                    errors["password1"]?.append(Validation.Error.MissingValue())
                }

                var _password2: String = String()
                do {
                    _password2 = try Request.extract(param: "password2", from: dictionary)

                    if let error = Validation.Identical(right: _password1, message: "Passwords must match").validate(input: _password2) {
                        errors["password2"]?.append(error)
                    }
                } catch Entita.E.ExtractError {
                    errors["password2"]?.append(Validation.Error.MissingValue())
                }

                var _sex: String = String()
                do {
                    _sex = try Request.extract(param: "sex", from: dictionary)

                    if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(input: _sex) {
                        errors["sex"]?.append(error)
                    }
                } catch Entita.E.ExtractError {
                    errors["sex"]?.append(Validation.Error.MissingValue())
                }

                var _ip: String = String()
                do {
                    _ip = try Request.extract(param: "ip", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["ip"]?.append(Validation.Error.MissingValue())
                }

                var _userAgent: String = String()
                do {
                    _userAgent = try Request.extract(param: "userAgent", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["userAgent"]?.append(Validation.Error.MissingValue())
                }

                var _country: String = String()
                do {
                    _country = try Request.extract(param: "country", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["country"]?.append(Validation.Error.MissingValue())
                }

                let filteredErrors = errors.filter({ _, value in value.count > 0 })
                guard filteredErrors.count == 0 else {
                    throw LGNC.E.DecodeError(filteredErrors)
                }

                let instance = self.init(
                    email: _email,
                    password1: _password1,
                    password2: _password2,
                    sex: _sex,
                    ip: _ip,
                    userAgent: _userAgent,
                    country: _country
                )

                return instance
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary),
                    sex: try Request.extract(param: "sex", from: dictionary),
                    ip: try Request.extract(param: "ip", from: dictionary),
                    userAgent: try Request.extract(param: "userAgent", from: dictionary),
                    country: try Request.extract(param: "country", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("ip"): try self.encode(self.ip),
                    self.getDictionaryKey("userAgent"): try self.encode(self.userAgent),
                    self.getDictionaryKey("country"): try self.encode(self.country),
                ]
            }

            public static func validateEmail(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback
            ) {
                self.validatorEmailClosure = callback
            }
        }
    }

    public struct InternalLogin: Contract {
        public typealias ParentService = Services.Author
        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "InternalLogin"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeInternalLoginContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeInternalLoginContract(callback)
        }
    }

    public struct Authenticate: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "Authenticate"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeAuthenticateContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeAuthenticateContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "portal": "b",
                "token": "c",
            ]

            public let portal: String
            public let token: String

            public required init(
                portal: String,
                token: String
            ) {
                self.portal = portal
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict) throws -> Request {
                var errors: [String: [ValidatorError]] = [
                    "portal": [],
                    "token": [],
                ]

                var _portal: String = String()
                do {
                    _portal = try Request.extract(param: "portal", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["portal"]?.append(Validation.Error.MissingValue())
                }

                var _token: String = String()
                do {
                    _token = try Request.extract(param: "token", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["token"]?.append(Validation.Error.MissingValue())
                }

                let filteredErrors = errors.filter({ _, value in value.count > 0 })
                guard filteredErrors.count == 0 else {
                    throw LGNC.E.DecodeError(filteredErrors)
                }

                let instance = self.init(
                    portal: _portal,
                    token: _token
                )

                return instance
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    portal: try Request.extract(param: "portal", from: dictionary),
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "isAuthenticated": "b",
            ]

            public let isAuthenticated: Bool

            public required init(
                isAuthenticated: Bool
            ) {
                self.isAuthenticated = isAuthenticated
            }

            public static func initWithValidation(from dictionary: Entita.Dict) throws -> Response {
                var errors: [String: [ValidatorError]] = [
                    "isAuthenticated": [],
                ]

                var _isAuthenticated: Bool = Bool()
                do {
                    _isAuthenticated = try Response.extract(param: "isAuthenticated", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["isAuthenticated"]?.append(Validation.Error.MissingValue())
                }

                let filteredErrors = errors.filter({ _, value in value.count > 0 })
                guard filteredErrors.count == 0 else {
                    throw LGNC.E.DecodeError(filteredErrors)
                }

                let instance = self.init(
                    isAuthenticated: _isAuthenticated
                )

                return instance
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    isAuthenticated: try Response.extract(param: "isAuthenticated", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("isAuthenticated"): try self.encode(self.isAuthenticated),
                ]
            }
        }
    }
}
