/**
 * This file has been autogenerated by LGNC assembler on 2018-10-12 12:31:55.770806.
 * All changes will be lost on next assembly.
 */

import Entita
import LGNC
import LGNCore
import LGNP
import NIO

public extension Services {
    public struct Quorum: Service {
        public static let port = 1713

        public struct Contracts {}

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static let contractExecutorMap: [String: Executor] = [
            Contracts.Create.URI: Quorum.contractCreate,
        ]

        private static var contractCreateCallback: Contracts.Create.Callback!

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.Callback) {
            self.contractCreateCallback = callback
        }

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.NonFutureCallback) {
            self.guaranteeCreateContract { (request, requestInfo) -> EventLoopFuture<Contracts.Create.Response> in
                let promise: EventLoopPromise<Contracts.Create.Response> = requestInfo.eventLoop.newPromise()
                do {
                    promise.succeed(result: try callback(request, requestInfo))
                } catch {
                    promise.fail(error: error)
                }
                return promise.futureResult
            }
        }

        public static func executeCreateContract(
            at address: Address,
            with request: Contracts.Create.Request,
            salt: String,
            key: String? = nil,
            on eventLoop: EventLoop,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> EventLoopFuture<Contracts.Create.Response> {
            return Contracts.Create.execute(
                at: address,
                with: request,
                salt: salt,
                key: key,
                on: eventLoop,
                controlBitmask: controlBitmask,
                uuid: uuid
            )
        }

        private static func contractCreate(
            message _: LGNP.Message,
            requestInfo: RequestInfo,
            parsedDict: Entita.Dict
        ) throws -> EventLoopFuture<ContractEntity> {
            guard let callback = self.contractCreateCallback else {
                throw LGNC.E.ControllerError("No callback for contract 'Create'")
            }
            return callback(
                try Contracts.Create.Request.initWithValidation(from: parsedDict),
                requestInfo
            ).map { $0 as ContractEntity }
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractCreateCallback == nil {
                LGNCore.log("Contract 'Create' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Create": [
                "Request": Contracts.Create.Request.keyDictionary,
                "Response": Contracts.Create.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Quorum.Contracts {
    public struct Create: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Create"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "IDPost": "b",
                "IDReplyComment": "c",
                "body": "d",
            ]

            public let IDPost: Int
            public let IDReplyComment: String?
            public let body: String

            public required init(
                IDPost: Int,
                IDReplyComment: String? = nil,
                body: String
            ) {
                self.IDPost = IDPost
                self.IDReplyComment = IDReplyComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict) throws -> Request {
                var errors: [String: [ValidatorError]] = [
                    "IDPost": [],
                    "IDReplyComment": [],
                    "body": [],
                ]

                var _IDPost: Int = Int()
                do {
                    _IDPost = try Request.extract(param: "IDPost", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["IDPost"]?.append(Validation.Error.MissingValue())
                }

                var _IDReplyComment: String?
                do {
                    _IDReplyComment = try Request.extract(param: "IDReplyComment", from: dictionary)

                } catch Entita.E.ExtractError {
                    errors["IDReplyComment"]?.append(Validation.Error.MissingValue())
                }

                var _body: String = String()
                do {
                    _body = try Request.extract(param: "body", from: dictionary)

                    if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(input: _body) {
                        errors["body"]?.append(error)
                    }

                    if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(input: _body) {
                        errors["body"]?.append(error)
                    }
                } catch Entita.E.ExtractError {
                    errors["body"]?.append(Validation.Error.MissingValue())
                }

                let filteredErrors = errors.filter({ _, value in value.count > 0 })
                guard filteredErrors.count == 0 else {
                    throw LGNC.E.DecodeError(filteredErrors)
                }

                let instance = self.init(
                    IDPost: _IDPost,
                    IDReplyComment: _IDReplyComment,
                    body: _body
                )

                return instance
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    IDReplyComment: try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("IDReplyComment"): try self.encode(self.IDReplyComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }
        }
    }
}
