/**
 * This file has been autogenerated by LGNC assembler on 2018-12-26 15:33:59.248097.
 * All changes will be lost on next assembly.
 */

import Entita
import Foundation
import LGNC
import LGNCore
import LGNP
import LGNS
import NIO

public extension Services {
    public struct Quorum: Service {
        public static let port = 1713

        public struct Contracts {}

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static let contractExecutorMap: [String: Executor] = [
            Contracts.Create.URI: Quorum.contractCreate,
        ]

        private static var contractCreateCallback: Contracts.Create.NormalizedCallback!

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.Callback) {
            self.contractCreateCallback = Contracts.Create.normalize(callback: callback)
        }

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.NonFutureCallback) {
            self.guaranteeCreateContract(Contracts.Create.futurize(callback: callback))
        }

        public static func executeCreateContract(
            at address: Address,
            with request: Contracts.Create.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Create.Response> {
            return Contracts.Create.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        private static func contractCreate(requestInfo: RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Create._invoke(with: self.contractCreateCallback, request: parsedDict, requestInfo: requestInfo, name: "Create")
        }

        public static func validateContractCreateFieldToken(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Create.Request.CallbackValidatorTokenAllowedValues>.Callback
        ) {
            Contracts.Create.Request.validateToken(callback)
        }

        public static func validateContractCreateFieldIdpost(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Create.Request.CallbackValidatorIdpostAllowedValues>.Callback
        ) {
            Contracts.Create.Request.validateIdpost(callback)
        }

        public static func validateContractCreateFieldIdreplycomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Create.Request.CallbackValidatorIdreplycommentAllowedValues>.Callback
        ) {
            Contracts.Create.Request.validateIdreplycomment(callback)
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractCreateCallback == nil {
                LGNCore.log("Contract 'Create' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Create": [
                "Request": Contracts.Create.Request.keyDictionary,
                "Response": Contracts.Create.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Quorum.Contracts {
    public struct Create: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "Create"
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorTokenAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case YouAreNotAuthorized = "You are not authorized"
                case YouAreForbiddenToLeaveCommentsHere = "You are forbidden to leave comments here"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .YouAreNotAuthorized: return (message: self.rawValue, code: 401)
                    case .YouAreForbiddenToLeaveCommentsHere: return (message: self.rawValue, code: 403)
                    }
                }
            }

            public enum CallbackValidatorIdpostAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case PostNotFound = "Post not found"
                case PostIsReadOnly = "Post is read only"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .PostNotFound: return (message: self.rawValue, code: 404)
                    case .PostIsReadOnly: return (message: self.rawValue, code: 403)
                    }
                }
            }

            public enum CallbackValidatorIdreplycommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case ReplyingCommentNotFound = "Replying comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .ReplyingCommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDPost": "c",
                "IDReplyComment": "d",
                "body": "e",
            ]

            public let token: String
            public let IDPost: Int
            public let IDReplyComment: String?
            public let body: String

            private static var validatorTokenClosure: Validation.CallbackWithAllowedValues<CallbackValidatorTokenAllowedValues>.Callback?
            private static var validatorIdpostClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback?
            private static var validatorIdreplycommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback?

            public required init(
                token: String,
                IDPost: Int,
                IDReplyComment: String? = nil,
                body: String
            ) {
                self.token = token
                self.IDPost = IDPost
                self.IDReplyComment = IDReplyComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDPost": [],
                    "IDReplyComment": [],
                    "body": [],
                ]

                var _token: String = String()
                var _IDPost: Int = Int()
                var _IDReplyComment: String?
                var _body: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)

                        if let validatorTokenClosure = self.validatorTokenClosure {
                            validatorFutures["token"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorTokenAllowedValues>(callback: validatorTokenClosure).validate(
                                    input: _token,
                                    on: eventLoop
                                ).map { ("token", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDPost = try Request.extract(param: "IDPost", from: dictionary)

                        if let validatorIdpostClosure = self.validatorIdpostClosure {
                            validatorFutures["IDPost"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>(callback: validatorIdpostClosure).validate(
                                    input: _IDPost,
                                    on: eventLoop
                                ).map { ("IDPost", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDPost"]!.append(eventLoop.newSucceededFuture(result: ("IDPost", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDReplyComment = try Request.extract(param: "IDReplyComment", from: dictionary)

                        if let _IDReplyComment = _IDReplyComment, let validatorIdreplycommentClosure = self.validatorIdreplycommentClosure {
                            validatorFutures["IDReplyComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>(callback: validatorIdreplycommentClosure).validate(
                                    input: _IDReplyComment,
                                    on: eventLoop
                                ).map { ("IDReplyComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDReplyComment"]!.append(eventLoop.newSucceededFuture(result: ("IDReplyComment", Validation.Error.MissingValue())))
                    }
                    do {
                        _body = try Request.extract(param: "body", from: dictionary)

                        if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }

                        if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDPost: _IDPost,
                        IDReplyComment: _IDReplyComment,
                        body: _body
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    IDReplyComment: try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("IDReplyComment"): try self.encode(self.IDReplyComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateToken(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorTokenAllowedValues>.Callback
            ) {
                self.validatorTokenClosure = callback
            }

            public static func validateIdpost(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback
            ) {
                self.validatorIdpostClosure = callback
            }

            public static func validateIdreplycomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback
            ) {
                self.validatorIdreplycommentClosure = callback
            }
        }
    }
}
