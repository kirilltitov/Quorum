/**
 * This file has been autogenerated by LGNC assembler on 2019-06-13 21:39:03.927015.
 * All changes will be lost on next assembly.
 */

import Entita
import Foundation
import LGNC
import LGNCore
import LGNP
import LGNS
import NIO

public extension Services {
    struct Quorum: Service {
        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public struct Contracts {}

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static let contractMap: Contract.Map = [
            Contracts.DeleteComment.URI: (transports: Contracts.DeleteComment.transports, executor: Quorum.contractDeleteComment),
            Contracts.UndeleteComment.URI: (transports: Contracts.UndeleteComment.transports, executor: Quorum.contractUndeleteComment),
            Contracts.HideComment.URI: (transports: Contracts.HideComment.transports, executor: Quorum.contractHideComment),
            Contracts.UnhideComment.URI: (transports: Contracts.UnhideComment.transports, executor: Quorum.contractUnhideComment),
            Contracts.ApproveComment.URI: (transports: Contracts.ApproveComment.transports, executor: Quorum.contractApproveComment),
            Contracts.Comments.URI: (transports: Contracts.Comments.transports, executor: Quorum.contractComments),
            Contracts.CreateComment.URI: (transports: Contracts.CreateComment.transports, executor: Quorum.contractCreateComment),
            Contracts.EditComment.URI: (transports: Contracts.EditComment.transports, executor: Quorum.contractEditComment),
            Contracts.LikeComment.URI: (transports: Contracts.LikeComment.transports, executor: Quorum.contractLikeComment),
            Contracts.PendingComments.URI: (transports: Contracts.PendingComments.transports, executor: Quorum.contractPendingComments),
            Contracts.RejectComment.URI: (transports: Contracts.RejectComment.transports, executor: Quorum.contractRejectComment),
        ]

        private static var contractDeleteCommentCallback: Contracts.DeleteComment.NormalizedCallback!
        private static var contractUndeleteCommentCallback: Contracts.UndeleteComment.NormalizedCallback!
        private static var contractHideCommentCallback: Contracts.HideComment.NormalizedCallback!
        private static var contractUnhideCommentCallback: Contracts.UnhideComment.NormalizedCallback!
        private static var contractApproveCommentCallback: Contracts.ApproveComment.NormalizedCallback!
        private static var contractCommentsCallback: Contracts.Comments.NormalizedCallback!
        private static var contractCreateCommentCallback: Contracts.CreateComment.NormalizedCallback!
        private static var contractEditCommentCallback: Contracts.EditComment.NormalizedCallback!
        private static var contractLikeCommentCallback: Contracts.LikeComment.NormalizedCallback!
        private static var contractPendingCommentsCallback: Contracts.PendingComments.NormalizedCallback!
        private static var contractRejectCommentCallback: Contracts.RejectComment.NormalizedCallback!

        public static func guaranteeDeleteCommentContract(_ callback: @escaping Contracts.DeleteComment.Callback) {
            self.contractDeleteCommentCallback = Contracts.DeleteComment.normalize(callback: callback)
        }

        public static func guaranteeDeleteCommentContract(_ callback: @escaping Contracts.DeleteComment.NonFutureCallback) {
            self.guaranteeDeleteCommentContract(Contracts.DeleteComment.futurize(callback: callback))
        }

        public static func guaranteeUndeleteCommentContract(_ callback: @escaping Contracts.UndeleteComment.Callback) {
            self.contractUndeleteCommentCallback = Contracts.UndeleteComment.normalize(callback: callback)
        }

        public static func guaranteeUndeleteCommentContract(_ callback: @escaping Contracts.UndeleteComment.NonFutureCallback) {
            self.guaranteeUndeleteCommentContract(Contracts.UndeleteComment.futurize(callback: callback))
        }

        public static func guaranteeHideCommentContract(_ callback: @escaping Contracts.HideComment.Callback) {
            self.contractHideCommentCallback = Contracts.HideComment.normalize(callback: callback)
        }

        public static func guaranteeHideCommentContract(_ callback: @escaping Contracts.HideComment.NonFutureCallback) {
            self.guaranteeHideCommentContract(Contracts.HideComment.futurize(callback: callback))
        }

        public static func guaranteeUnhideCommentContract(_ callback: @escaping Contracts.UnhideComment.Callback) {
            self.contractUnhideCommentCallback = Contracts.UnhideComment.normalize(callback: callback)
        }

        public static func guaranteeUnhideCommentContract(_ callback: @escaping Contracts.UnhideComment.NonFutureCallback) {
            self.guaranteeUnhideCommentContract(Contracts.UnhideComment.futurize(callback: callback))
        }

        public static func guaranteeApproveCommentContract(_ callback: @escaping Contracts.ApproveComment.Callback) {
            self.contractApproveCommentCallback = Contracts.ApproveComment.normalize(callback: callback)
        }

        public static func guaranteeApproveCommentContract(_ callback: @escaping Contracts.ApproveComment.NonFutureCallback) {
            self.guaranteeApproveCommentContract(Contracts.ApproveComment.futurize(callback: callback))
        }

        public static func guaranteeCommentsContract(_ callback: @escaping Contracts.Comments.Callback) {
            self.contractCommentsCallback = Contracts.Comments.normalize(callback: callback)
        }

        public static func guaranteeCommentsContract(_ callback: @escaping Contracts.Comments.NonFutureCallback) {
            self.guaranteeCommentsContract(Contracts.Comments.futurize(callback: callback))
        }

        public static func guaranteeCreateCommentContract(_ callback: @escaping Contracts.CreateComment.Callback) {
            self.contractCreateCommentCallback = Contracts.CreateComment.normalize(callback: callback)
        }

        public static func guaranteeCreateCommentContract(_ callback: @escaping Contracts.CreateComment.NonFutureCallback) {
            self.guaranteeCreateCommentContract(Contracts.CreateComment.futurize(callback: callback))
        }

        public static func guaranteeEditCommentContract(_ callback: @escaping Contracts.EditComment.Callback) {
            self.contractEditCommentCallback = Contracts.EditComment.normalize(callback: callback)
        }

        public static func guaranteeEditCommentContract(_ callback: @escaping Contracts.EditComment.NonFutureCallback) {
            self.guaranteeEditCommentContract(Contracts.EditComment.futurize(callback: callback))
        }

        public static func guaranteeLikeCommentContract(_ callback: @escaping Contracts.LikeComment.Callback) {
            self.contractLikeCommentCallback = Contracts.LikeComment.normalize(callback: callback)
        }

        public static func guaranteeLikeCommentContract(_ callback: @escaping Contracts.LikeComment.NonFutureCallback) {
            self.guaranteeLikeCommentContract(Contracts.LikeComment.futurize(callback: callback))
        }

        public static func guaranteePendingCommentsContract(_ callback: @escaping Contracts.PendingComments.Callback) {
            self.contractPendingCommentsCallback = Contracts.PendingComments.normalize(callback: callback)
        }

        public static func guaranteePendingCommentsContract(_ callback: @escaping Contracts.PendingComments.NonFutureCallback) {
            self.guaranteePendingCommentsContract(Contracts.PendingComments.futurize(callback: callback))
        }

        public static func guaranteeRejectCommentContract(_ callback: @escaping Contracts.RejectComment.Callback) {
            self.contractRejectCommentCallback = Contracts.RejectComment.normalize(callback: callback)
        }

        public static func guaranteeRejectCommentContract(_ callback: @escaping Contracts.RejectComment.NonFutureCallback) {
            self.guaranteeRejectCommentContract(Contracts.RejectComment.futurize(callback: callback))
        }

        public static func executeDeleteCommentContract(
            at address: Address,
            with request: Contracts.DeleteComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.DeleteComment.Response> {
            return Contracts.DeleteComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUndeleteCommentContract(
            at address: Address,
            with request: Contracts.UndeleteComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.UndeleteComment.Response> {
            return Contracts.UndeleteComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeHideCommentContract(
            at address: Address,
            with request: Contracts.HideComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.HideComment.Response> {
            return Contracts.HideComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUnhideCommentContract(
            at address: Address,
            with request: Contracts.UnhideComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.UnhideComment.Response> {
            return Contracts.UnhideComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeApproveCommentContract(
            at address: Address,
            with request: Contracts.ApproveComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ApproveComment.Response> {
            return Contracts.ApproveComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeCommentsContract(
            at address: Address,
            with request: Contracts.Comments.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Comments.Response> {
            return Contracts.Comments.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeCreateCommentContract(
            at address: Address,
            with request: Contracts.CreateComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.CreateComment.Response> {
            return Contracts.CreateComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeEditCommentContract(
            at address: Address,
            with request: Contracts.EditComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.EditComment.Response> {
            return Contracts.EditComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeLikeCommentContract(
            at address: Address,
            with request: Contracts.LikeComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.LikeComment.Response> {
            return Contracts.LikeComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executePendingCommentsContract(
            at address: Address,
            with request: Contracts.PendingComments.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.PendingComments.Response> {
            return Contracts.PendingComments.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeRejectCommentContract(
            at address: Address,
            with request: Contracts.RejectComment.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.RejectComment.Response> {
            return Contracts.RejectComment.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        private static func contractDeleteComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.DeleteComment._invoke(with: self.contractDeleteCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "DeleteComment")
        }

        private static func contractUndeleteComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.UndeleteComment._invoke(with: self.contractUndeleteCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "UndeleteComment")
        }

        private static func contractHideComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.HideComment._invoke(with: self.contractHideCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "HideComment")
        }

        private static func contractUnhideComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.UnhideComment._invoke(with: self.contractUnhideCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "UnhideComment")
        }

        private static func contractApproveComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ApproveComment._invoke(with: self.contractApproveCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "ApproveComment")
        }

        private static func contractComments(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Comments._invoke(with: self.contractCommentsCallback, request: parsedDict, requestInfo: requestInfo, name: "Comments")
        }

        private static func contractCreateComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.CreateComment._invoke(with: self.contractCreateCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "CreateComment")
        }

        private static func contractEditComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.EditComment._invoke(with: self.contractEditCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "EditComment")
        }

        private static func contractLikeComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.LikeComment._invoke(with: self.contractLikeCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "LikeComment")
        }

        private static func contractPendingComments(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.PendingComments._invoke(with: self.contractPendingCommentsCallback, request: parsedDict, requestInfo: requestInfo, name: "PendingComments")
        }

        private static func contractRejectComment(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.RejectComment._invoke(with: self.contractRejectCommentCallback, request: parsedDict, requestInfo: requestInfo, name: "RejectComment")
        }

        public static func validateContractDeleteCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.DeleteComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.DeleteComment.Request.validateIdcomment(callback)
        }

        public static func validateContractUndeleteCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.UndeleteComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.UndeleteComment.Request.validateIdcomment(callback)
        }

        public static func validateContractHideCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.HideComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.HideComment.Request.validateIdcomment(callback)
        }

        public static func validateContractUnhideCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.UnhideComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.UnhideComment.Request.validateIdcomment(callback)
        }

        public static func validateContractApproveCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.ApproveComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.ApproveComment.Request.validateIdcomment(callback)
        }

        public static func validateContractCreateCommentFieldIdpost(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.CreateComment.Request.CallbackValidatorIdpostAllowedValues>.Callback
        ) {
            Contracts.CreateComment.Request.validateIdpost(callback)
        }

        public static func validateContractCreateCommentFieldIdreplycomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.CreateComment.Request.CallbackValidatorIdreplycommentAllowedValues>.Callback
        ) {
            Contracts.CreateComment.Request.validateIdreplycomment(callback)
        }

        public static func validateContractEditCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.EditComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.EditComment.Request.validateIdcomment(callback)
        }

        public static func validateContractLikeCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.LikeComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.LikeComment.Request.validateIdcomment(callback)
        }

        public static func validateContractRejectCommentFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.RejectComment.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.RejectComment.Request.validateIdcomment(callback)
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractDeleteCommentCallback == nil {
                Logger(label: "LGNC.Contracts.DeleteComment").error("Contract 'DeleteComment' is not guaranteed")
                result = false
            }

            if self.contractUndeleteCommentCallback == nil {
                Logger(label: "LGNC.Contracts.UndeleteComment").error("Contract 'UndeleteComment' is not guaranteed")
                result = false
            }

            if self.contractHideCommentCallback == nil {
                Logger(label: "LGNC.Contracts.HideComment").error("Contract 'HideComment' is not guaranteed")
                result = false
            }

            if self.contractUnhideCommentCallback == nil {
                Logger(label: "LGNC.Contracts.UnhideComment").error("Contract 'UnhideComment' is not guaranteed")
                result = false
            }

            if self.contractApproveCommentCallback == nil {
                Logger(label: "LGNC.Contracts.ApproveComment").error("Contract 'ApproveComment' is not guaranteed")
                result = false
            }

            if self.contractCommentsCallback == nil {
                Logger(label: "LGNC.Contracts.Comments").error("Contract 'Comments' is not guaranteed")
                result = false
            }

            if self.contractCreateCommentCallback == nil {
                Logger(label: "LGNC.Contracts.CreateComment").error("Contract 'CreateComment' is not guaranteed")
                result = false
            }

            if self.contractEditCommentCallback == nil {
                Logger(label: "LGNC.Contracts.EditComment").error("Contract 'EditComment' is not guaranteed")
                result = false
            }

            if self.contractLikeCommentCallback == nil {
                Logger(label: "LGNC.Contracts.LikeComment").error("Contract 'LikeComment' is not guaranteed")
                result = false
            }

            if self.contractPendingCommentsCallback == nil {
                Logger(label: "LGNC.Contracts.PendingComments").error("Contract 'PendingComments' is not guaranteed")
                result = false
            }

            if self.contractRejectCommentCallback == nil {
                Logger(label: "LGNC.Contracts.RejectComment").error("Contract 'RejectComment' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "DeleteComment": [
                "Request": Contracts.DeleteComment.Request.keyDictionary,
                "Response": Contracts.DeleteComment.Response.keyDictionary,
            ],
            "UndeleteComment": [
                "Request": Contracts.UndeleteComment.Request.keyDictionary,
                "Response": Contracts.UndeleteComment.Response.keyDictionary,
            ],
            "HideComment": [
                "Request": Contracts.HideComment.Request.keyDictionary,
                "Response": Contracts.HideComment.Response.keyDictionary,
            ],
            "UnhideComment": [
                "Request": Contracts.UnhideComment.Request.keyDictionary,
                "Response": Contracts.UnhideComment.Response.keyDictionary,
            ],
            "ApproveComment": [
                "Request": Contracts.ApproveComment.Request.keyDictionary,
                "Response": Contracts.ApproveComment.Response.keyDictionary,
            ],
            "Comments": [
                "Request": Contracts.Comments.Request.keyDictionary,
                "Response": Contracts.Comments.Response.keyDictionary,
            ],
            "CreateComment": [
                "Request": Contracts.CreateComment.Request.keyDictionary,
                "Response": Contracts.CreateComment.Response.keyDictionary,
            ],
            "EditComment": [
                "Request": Contracts.EditComment.Request.keyDictionary,
                "Response": Contracts.EditComment.Response.keyDictionary,
            ],
            "LikeComment": [
                "Request": Contracts.LikeComment.Request.keyDictionary,
                "Response": Contracts.LikeComment.Response.keyDictionary,
            ],
            "PendingComments": [
                "Request": Contracts.PendingComments.Request.keyDictionary,
                "Response": Contracts.PendingComments.Response.keyDictionary,
            ],
            "RejectComment": [
                "Request": Contracts.RejectComment.Request.keyDictionary,
                "Response": Contracts.RejectComment.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Quorum.Contracts {
    typealias FieldMapping = Services.Shared.FieldMapping
    typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    typealias CharacterInfo = Services.Shared.CharacterInfo
    typealias EventRequest = Services.Shared.EventRequest
    typealias UserSignupRequest = Services.Shared.UserSignupRequest
    typealias NodeInfo = Services.Shared.NodeInfo
    typealias PingRequest = Services.Shared.PingRequest
    typealias PingResponse = Services.Shared.PingResponse
    typealias CheckinRequest = Services.Shared.CheckinRequest
    typealias CheckinResponse = Services.Shared.CheckinResponse
    typealias LoginRequest = Services.Shared.LoginRequest
    typealias LoginResponse = Services.Shared.LoginResponse
    typealias CommentUserInfo = Services.Shared.CommentUserInfo
    typealias Empty = Services.Shared.Empty
    typealias Comment = Services.Shared.Comment
    typealias User = Services.Shared.User

    struct DeleteComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "DeleteComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeDeleteCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeDeleteCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct UndeleteComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "UndeleteComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeUndeleteCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeUndeleteCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct HideComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "HideComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeHideCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeHideCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct UnhideComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "UnhideComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeUnhideCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeUnhideCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct ApproveComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "ApproveComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeApproveCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeApproveCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct Comments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "Comments"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCommentsContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCommentsContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "IDPost": "b",
                "token": "c",
            ]

            public let IDPost: Int
            public let token: String?

            public init(
                IDPost: Int,
                token: String? = nil
            ) {
                self.IDPost = IDPost
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "IDPost": [],
                    "token": [],
                ]

                var _IDPost: Int = Int()
                var _token: String?

                do {
                    do {
                        _IDPost = try Request.extract(param: "IDPost", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDPost"]!.append(eventLoop.makeSucceededFuture(("IDPost", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _token = try Request.extract(param: "token", from: dictionary, isOptional: true)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            IDPost: _IDPost,
                            token: _token
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    token: try Request.extract(param: "token", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "comments": "b",
            ]

            public let comments: [Comment]

            public init(
                comments: [Comment]
            ) {
                self.comments = comments
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "comments": [],
                ]

                var _comments: [Comment] = [Comment]()

                do {
                    do {
                        _comments = try Response.extract(param: "comments", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["comments"]!.append(eventLoop.makeSucceededFuture(("comments", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            comments: _comments
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }
        }
    }

    struct CreateComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "CreateComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCreateCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCreateCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdpostAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case PostNotFound = "Post not found"
                case PostIsReadOnly = "Post is read only"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .PostNotFound: return (message: self.rawValue, code: 404)
                    case .PostIsReadOnly: return (message: self.rawValue, code: 403)
                    }
                }
            }

            public enum CallbackValidatorIdreplycommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case ReplyingCommentNotFound = "Replying comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .ReplyingCommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDPost": "c",
                "IDReplyComment": "d",
                "body": "e",
            ]

            public let token: String
            public let IDPost: Int
            public let IDReplyComment: Int?
            public let body: String

            private static var validatorIdpostClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback?
            private static var validatorIdreplycommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback?

            public init(
                token: String,
                IDPost: Int,
                IDReplyComment: Int? = nil,
                body: String
            ) {
                self.token = token
                self.IDPost = IDPost
                self.IDReplyComment = IDReplyComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDPost": [],
                    "IDReplyComment": [],
                    "body": [],
                ]

                var _token: String = String()
                var _IDPost: Int = Int()
                var _IDReplyComment: Int?
                var _body: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDPost = try Request.extract(param: "IDPost", from: dictionary)

                        if let validatorIdpostClosure = self.validatorIdpostClosure {
                            validatorFutures["IDPost"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>(callback: validatorIdpostClosure).validate(
                                    _IDPost,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDPost", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDPost"]!.append(eventLoop.makeSucceededFuture(("IDPost", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _IDReplyComment = try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true)

                        if let _IDReplyComment = _IDReplyComment, let validatorIdreplycommentClosure = self.validatorIdreplycommentClosure {
                            validatorFutures["IDReplyComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>(callback: validatorIdreplycommentClosure).validate(
                                    _IDReplyComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDReplyComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDReplyComment"]!.append(eventLoop.makeSucceededFuture(("IDReplyComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _body = try Request.extract(param: "body", from: dictionary)

                        if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(_body, requestInfo.locale) {
                            validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", error)))
                        }

                        if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than {Length} characters long").validate(_body, requestInfo.locale) {
                            validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDPost: _IDPost,
                            IDReplyComment: _IDReplyComment,
                            body: _body
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    IDReplyComment: try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("IDReplyComment"): try self.encode(self.IDReplyComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIdpost(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback
            ) {
                self.validatorIdpostClosure = callback
            }

            public static func validateIdreplycomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback
            ) {
                self.validatorIdreplycommentClosure = callback
            }
        }
    }

    struct EditComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "EditComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeEditCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeEditCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
                "body": "d",
            ]

            public let token: String
            public let IDComment: Int
            public let body: String

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int,
                body: String
            ) {
                self.token = token
                self.IDComment = IDComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                    "body": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()
                var _body: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _body = try Request.extract(param: "body", from: dictionary)

                        if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(_body, requestInfo.locale) {
                            validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", error)))
                        }

                        if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than {Length} characters long").validate(_body, requestInfo.locale) {
                            validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["body"]!.append(eventLoop.makeSucceededFuture(("body", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment,
                            body: _body
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    struct LikeComment: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "LikeComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeLikeCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeLikeCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "likes": "b",
            ]

            public let likes: Int

            public init(
                likes: Int
            ) {
                self.likes = likes
            }

            public static func await(
                likes likesFuture: Future<Int>
            ) -> Future<Response> {
                return likesFuture.eventLoop.makeSucceededFuture(()).flatMap { () in
                    likesFuture.map { likes in likes }
                }
                .map { likes in
                    Response(
                        likes: likes
                    )
                }
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "likes": [],
                ]

                var _likes: Int = Int()

                do {
                    do {
                        _likes = try Response.extract(param: "likes", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["likes"]!.append(eventLoop.makeSucceededFuture(("likes", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            likes: _likes
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    likes: try Response.extract(param: "likes", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("likes"): try self.encode(self.likes),
                ]
            }
        }
    }

    struct PendingComments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "PendingComments"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteePendingCommentsContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteePendingCommentsContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
            ]

            public let token: String

            public init(
                token: String
            ) {
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                ]

                var _token: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale, message: "Not authorized", code: 403))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "comments": "b",
            ]

            public let comments: [Comment]

            public init(
                comments: [Comment]
            ) {
                self.comments = comments
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "comments": [],
                ]

                var _comments: [Comment] = [Comment]()

                do {
                    do {
                        _comments = try Response.extract(param: "comments", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["comments"]!.append(eventLoop.makeSucceededFuture(("comments", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            comments: _comments
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }
        }
    }

    struct RejectComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RejectComment"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeRejectCommentContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeRejectCommentContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    _IDComment,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.makeSucceededFuture(("IDComment", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            IDComment: _IDComment
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }
}
