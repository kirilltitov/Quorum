/**
 * This file has been autogenerated by LGNC assembler on 2019-01-28 12:52:27.798692.
 * All changes will be lost on next assembly.
 */

import Entita
import Foundation
import LGNC
import LGNCore
import LGNP
import LGNS
import NIO

public extension Services {
    public struct Quorum: Service {
        public static let transports: [LGNC.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public struct Contracts {}

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static let contractMap: Contract.Map = [
            Contracts.Comments.URI: (transports: Contracts.Comments.transports, executor: Quorum.contractComments),
            Contracts.UnapprovedComments.URI: (transports: Contracts.UnapprovedComments.transports, executor: Quorum.contractUnapprovedComments),
            Contracts.Create.URI: (transports: Contracts.Create.transports, executor: Quorum.contractCreate),
            Contracts.Edit.URI: (transports: Contracts.Edit.transports, executor: Quorum.contractEdit),
            Contracts.Delete.URI: (transports: Contracts.Delete.transports, executor: Quorum.contractDelete),
            Contracts.Undelete.URI: (transports: Contracts.Undelete.transports, executor: Quorum.contractUndelete),
            Contracts.Like.URI: (transports: Contracts.Like.transports, executor: Quorum.contractLike),
            Contracts.Approve.URI: (transports: Contracts.Approve.transports, executor: Quorum.contractApprove),
            Contracts.Reject.URI: (transports: Contracts.Reject.transports, executor: Quorum.contractReject),
            Contracts.RefreshUser.URI: (transports: Contracts.RefreshUser.transports, executor: Quorum.contractRefreshUser),
        ]

        private static var contractCommentsCallback: Contracts.Comments.NormalizedCallback!
        private static var contractUnapprovedCommentsCallback: Contracts.UnapprovedComments.NormalizedCallback!
        private static var contractCreateCallback: Contracts.Create.NormalizedCallback!
        private static var contractEditCallback: Contracts.Edit.NormalizedCallback!
        private static var contractDeleteCallback: Contracts.Delete.NormalizedCallback!
        private static var contractUndeleteCallback: Contracts.Undelete.NormalizedCallback!
        private static var contractLikeCallback: Contracts.Like.NormalizedCallback!
        private static var contractApproveCallback: Contracts.Approve.NormalizedCallback!
        private static var contractRejectCallback: Contracts.Reject.NormalizedCallback!
        private static var contractRefreshUserCallback: Contracts.RefreshUser.NormalizedCallback!

        public static func guaranteeCommentsContract(_ callback: @escaping Contracts.Comments.Callback) {
            self.contractCommentsCallback = Contracts.Comments.normalize(callback: callback)
        }

        public static func guaranteeCommentsContract(_ callback: @escaping Contracts.Comments.NonFutureCallback) {
            self.guaranteeCommentsContract(Contracts.Comments.futurize(callback: callback))
        }

        public static func guaranteeUnapprovedCommentsContract(_ callback: @escaping Contracts.UnapprovedComments.Callback) {
            self.contractUnapprovedCommentsCallback = Contracts.UnapprovedComments.normalize(callback: callback)
        }

        public static func guaranteeUnapprovedCommentsContract(_ callback: @escaping Contracts.UnapprovedComments.NonFutureCallback) {
            self.guaranteeUnapprovedCommentsContract(Contracts.UnapprovedComments.futurize(callback: callback))
        }

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.Callback) {
            self.contractCreateCallback = Contracts.Create.normalize(callback: callback)
        }

        public static func guaranteeCreateContract(_ callback: @escaping Contracts.Create.NonFutureCallback) {
            self.guaranteeCreateContract(Contracts.Create.futurize(callback: callback))
        }

        public static func guaranteeEditContract(_ callback: @escaping Contracts.Edit.Callback) {
            self.contractEditCallback = Contracts.Edit.normalize(callback: callback)
        }

        public static func guaranteeEditContract(_ callback: @escaping Contracts.Edit.NonFutureCallback) {
            self.guaranteeEditContract(Contracts.Edit.futurize(callback: callback))
        }

        public static func guaranteeDeleteContract(_ callback: @escaping Contracts.Delete.Callback) {
            self.contractDeleteCallback = Contracts.Delete.normalize(callback: callback)
        }

        public static func guaranteeDeleteContract(_ callback: @escaping Contracts.Delete.NonFutureCallback) {
            self.guaranteeDeleteContract(Contracts.Delete.futurize(callback: callback))
        }

        public static func guaranteeUndeleteContract(_ callback: @escaping Contracts.Undelete.Callback) {
            self.contractUndeleteCallback = Contracts.Undelete.normalize(callback: callback)
        }

        public static func guaranteeUndeleteContract(_ callback: @escaping Contracts.Undelete.NonFutureCallback) {
            self.guaranteeUndeleteContract(Contracts.Undelete.futurize(callback: callback))
        }

        public static func guaranteeLikeContract(_ callback: @escaping Contracts.Like.Callback) {
            self.contractLikeCallback = Contracts.Like.normalize(callback: callback)
        }

        public static func guaranteeLikeContract(_ callback: @escaping Contracts.Like.NonFutureCallback) {
            self.guaranteeLikeContract(Contracts.Like.futurize(callback: callback))
        }

        public static func guaranteeApproveContract(_ callback: @escaping Contracts.Approve.Callback) {
            self.contractApproveCallback = Contracts.Approve.normalize(callback: callback)
        }

        public static func guaranteeApproveContract(_ callback: @escaping Contracts.Approve.NonFutureCallback) {
            self.guaranteeApproveContract(Contracts.Approve.futurize(callback: callback))
        }

        public static func guaranteeRejectContract(_ callback: @escaping Contracts.Reject.Callback) {
            self.contractRejectCallback = Contracts.Reject.normalize(callback: callback)
        }

        public static func guaranteeRejectContract(_ callback: @escaping Contracts.Reject.NonFutureCallback) {
            self.guaranteeRejectContract(Contracts.Reject.futurize(callback: callback))
        }

        public static func guaranteeRefreshUserContract(_ callback: @escaping Contracts.RefreshUser.Callback) {
            self.contractRefreshUserCallback = Contracts.RefreshUser.normalize(callback: callback)
        }

        public static func guaranteeRefreshUserContract(_ callback: @escaping Contracts.RefreshUser.NonFutureCallback) {
            self.guaranteeRefreshUserContract(Contracts.RefreshUser.futurize(callback: callback))
        }

        public static func executeCommentsContract(
            at address: Address,
            with request: Contracts.Comments.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Comments.Response> {
            return Contracts.Comments.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUnapprovedCommentsContract(
            at address: Address,
            with request: Contracts.UnapprovedComments.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.UnapprovedComments.Response> {
            return Contracts.UnapprovedComments.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeCreateContract(
            at address: Address,
            with request: Contracts.Create.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Create.Response> {
            return Contracts.Create.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeEditContract(
            at address: Address,
            with request: Contracts.Edit.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Edit.Response> {
            return Contracts.Edit.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeDeleteContract(
            at address: Address,
            with request: Contracts.Delete.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Delete.Response> {
            return Contracts.Delete.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUndeleteContract(
            at address: Address,
            with request: Contracts.Undelete.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Undelete.Response> {
            return Contracts.Undelete.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeLikeContract(
            at address: Address,
            with request: Contracts.Like.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Like.Response> {
            return Contracts.Like.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeApproveContract(
            at address: Address,
            with request: Contracts.Approve.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Approve.Response> {
            return Contracts.Approve.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeRejectContract(
            at address: Address,
            with request: Contracts.Reject.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Reject.Response> {
            return Contracts.Reject.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeRefreshUserContract(
            at address: Address,
            with request: Contracts.RefreshUser.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.RefreshUser.Response> {
            return Contracts.RefreshUser.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        private static func contractComments(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Comments._invoke(with: self.contractCommentsCallback, request: parsedDict, requestInfo: requestInfo, name: "Comments")
        }

        private static func contractUnapprovedComments(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.UnapprovedComments._invoke(with: self.contractUnapprovedCommentsCallback, request: parsedDict, requestInfo: requestInfo, name: "UnapprovedComments")
        }

        private static func contractCreate(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Create._invoke(with: self.contractCreateCallback, request: parsedDict, requestInfo: requestInfo, name: "Create")
        }

        private static func contractEdit(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Edit._invoke(with: self.contractEditCallback, request: parsedDict, requestInfo: requestInfo, name: "Edit")
        }

        private static func contractDelete(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Delete._invoke(with: self.contractDeleteCallback, request: parsedDict, requestInfo: requestInfo, name: "Delete")
        }

        private static func contractUndelete(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Undelete._invoke(with: self.contractUndeleteCallback, request: parsedDict, requestInfo: requestInfo, name: "Undelete")
        }

        private static func contractLike(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Like._invoke(with: self.contractLikeCallback, request: parsedDict, requestInfo: requestInfo, name: "Like")
        }

        private static func contractApprove(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Approve._invoke(with: self.contractApproveCallback, request: parsedDict, requestInfo: requestInfo, name: "Approve")
        }

        private static func contractReject(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Reject._invoke(with: self.contractRejectCallback, request: parsedDict, requestInfo: requestInfo, name: "Reject")
        }

        private static func contractRefreshUser(requestInfo: LGNC.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.RefreshUser._invoke(with: self.contractRefreshUserCallback, request: parsedDict, requestInfo: requestInfo, name: "RefreshUser")
        }

        public static func validateContractCommentsFieldIdpost(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Comments.Request.CallbackValidatorIdpostAllowedValues>.Callback
        ) {
            Contracts.Comments.Request.validateIdpost(callback)
        }

        public static func validateContractCreateFieldIdpost(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Create.Request.CallbackValidatorIdpostAllowedValues>.Callback
        ) {
            Contracts.Create.Request.validateIdpost(callback)
        }

        public static func validateContractCreateFieldIdreplycomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Create.Request.CallbackValidatorIdreplycommentAllowedValues>.Callback
        ) {
            Contracts.Create.Request.validateIdreplycomment(callback)
        }

        public static func validateContractEditFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Edit.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Edit.Request.validateIdcomment(callback)
        }

        public static func validateContractDeleteFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Delete.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Delete.Request.validateIdcomment(callback)
        }

        public static func validateContractUndeleteFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Undelete.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Undelete.Request.validateIdcomment(callback)
        }

        public static func validateContractLikeFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Like.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Like.Request.validateIdcomment(callback)
        }

        public static func validateContractApproveFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Approve.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Approve.Request.validateIdcomment(callback)
        }

        public static func validateContractRejectFieldIdcomment(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Reject.Request.CallbackValidatorIdcommentAllowedValues>.Callback
        ) {
            Contracts.Reject.Request.validateIdcomment(callback)
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractCommentsCallback == nil {
                LGNCore.log("Contract 'Comments' is not guaranteed")
                result = false
            }

            if self.contractUnapprovedCommentsCallback == nil {
                LGNCore.log("Contract 'UnapprovedComments' is not guaranteed")
                result = false
            }

            if self.contractCreateCallback == nil {
                LGNCore.log("Contract 'Create' is not guaranteed")
                result = false
            }

            if self.contractEditCallback == nil {
                LGNCore.log("Contract 'Edit' is not guaranteed")
                result = false
            }

            if self.contractDeleteCallback == nil {
                LGNCore.log("Contract 'Delete' is not guaranteed")
                result = false
            }

            if self.contractUndeleteCallback == nil {
                LGNCore.log("Contract 'Undelete' is not guaranteed")
                result = false
            }

            if self.contractLikeCallback == nil {
                LGNCore.log("Contract 'Like' is not guaranteed")
                result = false
            }

            if self.contractApproveCallback == nil {
                LGNCore.log("Contract 'Approve' is not guaranteed")
                result = false
            }

            if self.contractRejectCallback == nil {
                LGNCore.log("Contract 'Reject' is not guaranteed")
                result = false
            }

            if self.contractRefreshUserCallback == nil {
                LGNCore.log("Contract 'RefreshUser' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Comments": [
                "Request": Contracts.Comments.Request.keyDictionary,
                "Response": Contracts.Comments.Response.keyDictionary,
            ],
            "UnapprovedComments": [
                "Request": Contracts.UnapprovedComments.Request.keyDictionary,
                "Response": Contracts.UnapprovedComments.Response.keyDictionary,
            ],
            "Create": [
                "Request": Contracts.Create.Request.keyDictionary,
                "Response": Contracts.Create.Response.keyDictionary,
            ],
            "Edit": [
                "Request": Contracts.Edit.Request.keyDictionary,
                "Response": Contracts.Edit.Response.keyDictionary,
            ],
            "Delete": [
                "Request": Contracts.Delete.Request.keyDictionary,
                "Response": Contracts.Delete.Response.keyDictionary,
            ],
            "Undelete": [
                "Request": Contracts.Undelete.Request.keyDictionary,
                "Response": Contracts.Undelete.Response.keyDictionary,
            ],
            "Like": [
                "Request": Contracts.Like.Request.keyDictionary,
                "Response": Contracts.Like.Response.keyDictionary,
            ],
            "Approve": [
                "Request": Contracts.Approve.Request.keyDictionary,
                "Response": Contracts.Approve.Response.keyDictionary,
            ],
            "Reject": [
                "Request": Contracts.Reject.Request.keyDictionary,
                "Response": Contracts.Reject.Response.keyDictionary,
            ],
            "RefreshUser": [
                "Request": Contracts.RefreshUser.Request.keyDictionary,
                "Response": Contracts.RefreshUser.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Quorum.Contracts {
    public typealias FieldMapping = Services.Shared.FieldMapping
    public typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    public typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    public typealias CharacterInfo = Services.Shared.CharacterInfo
    public typealias UserSignupRequest = Services.Shared.UserSignupRequest
    public typealias UserSignupResponse = Services.Shared.UserSignupResponse
    public typealias NodeInfo = Services.Shared.NodeInfo
    public typealias PingRequest = Services.Shared.PingRequest
    public typealias PingResponse = Services.Shared.PingResponse
    public typealias CheckinRequest = Services.Shared.CheckinRequest
    public typealias CheckinResponse = Services.Shared.CheckinResponse
    public typealias LoginRequest = Services.Shared.LoginRequest
    public typealias LoginResponse = Services.Shared.LoginResponse
    public typealias CommentUserInfo = Services.Shared.CommentUserInfo
    public typealias Comment = Services.Shared.Comment
    public typealias Empty = Services.Shared.Empty
    public typealias User = Services.Shared.User

    public struct Comments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "Comments"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.LGNS, .HTTP]
        public static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCommentsContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCommentsContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdpostAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case PostNotFound = "Post not found"
                case PostIsReadOnly = "Post is read only"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .PostNotFound: return (message: self.rawValue, code: 404)
                    case .PostIsReadOnly: return (message: self.rawValue, code: 403)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "IDPost": "b",
                "token": "c",
            ]

            public let IDPost: Int
            public let token: String?

            private static var validatorIdpostClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback?

            public init(
                IDPost: Int,
                token: String? = nil
            ) {
                self.IDPost = IDPost
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "IDPost": [],
                    "token": [],
                ]

                var _IDPost: Int = Int()
                var _token: String?

                do {
                    do {
                        _IDPost = try Request.extract(param: "IDPost", from: dictionary)

                        if let validatorIdpostClosure = self.validatorIdpostClosure {
                            validatorFutures["IDPost"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>(callback: validatorIdpostClosure).validate(
                                    input: _IDPost,
                                    on: eventLoop
                                ).map { ("IDPost", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDPost"]!.append(eventLoop.newSucceededFuture(result: ("IDPost", Validation.Error.MissingValue())))
                    }
                    do {
                        _token = try Request.extract(param: "token", from: dictionary, isOptional: true)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        IDPost: _IDPost,
                        token: _token
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    token: try Request.extract(param: "token", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }

            public static func validateIdpost(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback
            ) {
                self.validatorIdpostClosure = callback
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "comments": "b",
            ]

            public let comments: [Comment]

            public init(
                comments: [Comment]
            ) {
                self.comments = comments
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Response> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "comments": [],
                ]

                var _comments: [Comment] = [Comment]()

                do {
                    do {
                        _comments = try Response.extract(param: "comments", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["comments"]!.append(eventLoop.newSucceededFuture(result: ("comments", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        comments: _comments
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }
        }
    }

    public struct UnapprovedComments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "UnapprovedComments"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeUnapprovedCommentsContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeUnapprovedCommentsContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
            ]

            public let token: String

            public init(
                token: String
            ) {
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                ]

                var _token: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "comments": "b",
            ]

            public let comments: [Comment]

            public init(
                comments: [Comment]
            ) {
                self.comments = comments
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Response> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "comments": [],
                ]

                var _comments: [Comment] = [Comment]()

                do {
                    do {
                        _comments = try Response.extract(param: "comments", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["comments"]!.append(eventLoop.newSucceededFuture(result: ("comments", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        comments: _comments
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }
        }
    }

    public struct Create: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "Create"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.LGNS, .HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeCreateContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdpostAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case PostNotFound = "Post not found"
                case PostIsReadOnly = "Post is read only"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .PostNotFound: return (message: self.rawValue, code: 404)
                    case .PostIsReadOnly: return (message: self.rawValue, code: 403)
                    }
                }
            }

            public enum CallbackValidatorIdreplycommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case ReplyingCommentNotFound = "Replying comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .ReplyingCommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDPost": "c",
                "IDReplyComment": "d",
                "body": "e",
            ]

            public let token: String
            public let IDPost: Int
            public let IDReplyComment: Int?
            public let body: String

            private static var validatorIdpostClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback?
            private static var validatorIdreplycommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback?

            public init(
                token: String,
                IDPost: Int,
                IDReplyComment: Int? = nil,
                body: String
            ) {
                self.token = token
                self.IDPost = IDPost
                self.IDReplyComment = IDReplyComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDPost": [],
                    "IDReplyComment": [],
                    "body": [],
                ]

                var _token: String = String()
                var _IDPost: Int = Int()
                var _IDReplyComment: Int?
                var _body: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDPost = try Request.extract(param: "IDPost", from: dictionary)

                        if let validatorIdpostClosure = self.validatorIdpostClosure {
                            validatorFutures["IDPost"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>(callback: validatorIdpostClosure).validate(
                                    input: _IDPost,
                                    on: eventLoop
                                ).map { ("IDPost", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDPost"]!.append(eventLoop.newSucceededFuture(result: ("IDPost", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDReplyComment = try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true)

                        if let _IDReplyComment = _IDReplyComment, let validatorIdreplycommentClosure = self.validatorIdreplycommentClosure {
                            validatorFutures["IDReplyComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>(callback: validatorIdreplycommentClosure).validate(
                                    input: _IDReplyComment,
                                    on: eventLoop
                                ).map { ("IDReplyComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDReplyComment"]!.append(eventLoop.newSucceededFuture(result: ("IDReplyComment", Validation.Error.MissingValue())))
                    }
                    do {
                        _body = try Request.extract(param: "body", from: dictionary)

                        if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }

                        if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDPost: _IDPost,
                        IDReplyComment: _IDReplyComment,
                        body: _body
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    IDReplyComment: try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("IDReplyComment"): try self.encode(self.IDReplyComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIdpost(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdpostAllowedValues>.Callback
            ) {
                self.validatorIdpostClosure = callback
            }

            public static func validateIdreplycomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdreplycommentAllowedValues>.Callback
            ) {
                self.validatorIdreplycommentClosure = callback
            }
        }
    }

    public struct Edit: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "Edit"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.LGNS, .HTTP]
        public static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeEditContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeEditContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
                "body": "d",
            ]

            public let token: String
            public let IDComment: Int
            public let body: String

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int,
                body: String
            ) {
                self.token = token
                self.IDComment = IDComment
                self.body = body
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                    "body": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()
                var _body: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                    do {
                        _body = try Request.extract(param: "body", from: dictionary)

                        if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }

                        if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(input: _body) {
                            validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["body"]!.append(eventLoop.newSucceededFuture(result: ("body", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment,
                        body: _body
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    public struct Delete: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Delete"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.LGNS, .HTTP]
        public static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeDeleteContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeDeleteContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    public struct Undelete: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Undelete"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.LGNS, .HTTP]
        public static let contentTypes: [Services.ContentType] = [
            .MsgPack,
        ]

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeUndeleteContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeUndeleteContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    public struct Like: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "Like"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeLikeContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeLikeContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDComment": "c",
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "likes": "b",
            ]

            public let likes: Int

            public init(
                likes: Int
            ) {
                self.likes = likes
            }

            public static func await(
                on eventLoop: EventLoop,
                likes likesFuture: Future<Int>
            ) -> Future<Response> {
                return eventLoop.newSucceededFuture(result: ()).then { () in
                    likesFuture.map { likes in likes }
                }
                .map { likes in
                    Response(
                        likes: likes
                    )
                }
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Response> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "likes": [],
                ]

                var _likes: Int = Int()

                do {
                    do {
                        _likes = try Response.extract(param: "likes", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["likes"]!.append(eventLoop.newSucceededFuture(result: ("likes", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        likes: _likes
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    likes: try Response.extract(param: "likes", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("likes"): try self.encode(self.likes),
                ]
            }
        }
    }

    public struct Approve: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "Approve"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeApproveContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeApproveContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    public struct Reject: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Reject"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeRejectContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeRejectContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorIdcommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .CommentNotFound: return (message: self.rawValue, code: 404)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                :
            ]

            public let token: String
            public let IDComment: Int

            private static var validatorIdcommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback?

            public init(
                token: String,
                IDComment: Int
            ) {
                self.token = token
                self.IDComment = IDComment
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDComment": [],
                ]

                var _token: String = String()
                var _IDComment: Int = Int()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDComment = try Request.extract(param: "IDComment", from: dictionary)

                        if let validatorIdcommentClosure = self.validatorIdcommentClosure {
                            validatorFutures["IDComment"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>(callback: validatorIdcommentClosure).validate(
                                    input: _IDComment,
                                    on: eventLoop
                                ).map { ("IDComment", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDComment"]!.append(eventLoop.newSucceededFuture(result: ("IDComment", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDComment: _IDComment
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIdcomment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIdcommentAllowedValues>.Callback
            ) {
                self.validatorIdcommentClosure = callback
            }
        }
    }

    public struct RefreshUser: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RefreshUser"
        public static let visibility: ContractVisibility = .Private
        public static let transports: [LGNC.Transport] = [.HTTP]
        public static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Quorum.guaranteeRefreshUserContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Quorum.guaranteeRefreshUserContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
                "IDUser": "c",
            ]

            public let token: String
            public var IDUser: String

            public init(
                token: String,
                IDUser: String
            ) {
                self.token = token
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict, on eventLoop: EventLoop) -> Future<Request> {
                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "IDUser": [],
                ]

                var _token: String = String()
                var _IDUser: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.newSucceededFuture(result: ("token", Validation.Error.MissingValue())))
                    }
                    do {
                        _IDUser = try Request.extract(param: "IDUser", from: dictionary)

                        if let error = Validation.UUID().validate(input: _IDUser) {
                            validatorFutures["IDUser"]!.append(eventLoop.newSucceededFuture(result: ("IDUser", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDUser"]!.append(eventLoop.newSucceededFuture(result: ("IDUser", Validation.Error.MissingValue())))
                    }
                } catch {
                    return eventLoop.newFailedFuture(error: error)
                }

                return self.reduce(
                    validators: validatorFutures,
                    on: eventLoop
                ).thenThrowing { errors in
                    guard errors.count == 0 else {
                        throw LGNC.E.DecodeError(errors)
                    }
                    return self.init(
                        token: _token,
                        IDUser: _IDUser
                    )
                }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }
        }
    }
}
