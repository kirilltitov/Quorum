/**
 * This file has been autogenerated by LGNC assembler on 2020-10-03 10:48:38 +0000 (1601722118.442972).
 * All changes will be lost on next assembly.
 */

import Foundation
import LGNCore
import LGNP
import LGNC
import LGNS
import Entita
import NIO

public extension Services {
    enum Quorum: Service {
        public enum Contracts {}

        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static var guaranteeStatuses: [String: Bool] = [
            Contracts.DeleteComment.URI: Contracts.DeleteComment.isGuaranteed,
            Contracts.UndeleteComment.URI: Contracts.UndeleteComment.isGuaranteed,
            Contracts.HideComment.URI: Contracts.HideComment.isGuaranteed,
            Contracts.UnhideComment.URI: Contracts.UnhideComment.isGuaranteed,
            Contracts.ApproveComment.URI: Contracts.ApproveComment.isGuaranteed,
            Contracts.Comments.URI: Contracts.Comments.isGuaranteed,
            Contracts.CommentsCounters.URI: Contracts.CommentsCounters.isGuaranteed,
            Contracts.CreateComment.URI: Contracts.CreateComment.isGuaranteed,
            Contracts.EditComment.URI: Contracts.EditComment.isGuaranteed,
            Contracts.LikeComment.URI: Contracts.LikeComment.isGuaranteed,
            Contracts.PendingComments.URI: Contracts.PendingComments.isGuaranteed,
            Contracts.PendingCommentsCount.URI: Contracts.PendingCommentsCount.isGuaranteed,
            Contracts.RejectComment.URI: Contracts.RejectComment.isGuaranteed,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.isGuaranteed,
            Contracts.UserInfo.URI: Contracts.UserInfo.isGuaranteed,
        ]

        public static let contractMap: [String: AnyContract.Type] = [
            Contracts.DeleteComment.URI: Contracts.DeleteComment.self,
            Contracts.UndeleteComment.URI: Contracts.UndeleteComment.self,
            Contracts.HideComment.URI: Contracts.HideComment.self,
            Contracts.UnhideComment.URI: Contracts.UnhideComment.self,
            Contracts.ApproveComment.URI: Contracts.ApproveComment.self,
            Contracts.Comments.URI: Contracts.Comments.self,
            Contracts.CommentsCounters.URI: Contracts.CommentsCounters.self,
            Contracts.CreateComment.URI: Contracts.CreateComment.self,
            Contracts.EditComment.URI: Contracts.EditComment.self,
            Contracts.LikeComment.URI: Contracts.LikeComment.self,
            Contracts.PendingComments.URI: Contracts.PendingComments.self,
            Contracts.PendingCommentsCount.URI: Contracts.PendingCommentsCount.self,
            Contracts.RejectComment.URI: Contracts.RejectComment.self,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.self,
            Contracts.UserInfo.URI: Contracts.UserInfo.self,
        ]

        public static let keyDictionary: [String: Entita.Dict] = [
            "DeleteComment": [
                "Request": Contracts.DeleteComment.Request.keyDictionary,
                "Response": Contracts.DeleteComment.Response.keyDictionary,
            ],
            "UndeleteComment": [
                "Request": Contracts.UndeleteComment.Request.keyDictionary,
                "Response": Contracts.UndeleteComment.Response.keyDictionary,
            ],
            "HideComment": [
                "Request": Contracts.HideComment.Request.keyDictionary,
                "Response": Contracts.HideComment.Response.keyDictionary,
            ],
            "UnhideComment": [
                "Request": Contracts.UnhideComment.Request.keyDictionary,
                "Response": Contracts.UnhideComment.Response.keyDictionary,
            ],
            "ApproveComment": [
                "Request": Contracts.ApproveComment.Request.keyDictionary,
                "Response": Contracts.ApproveComment.Response.keyDictionary,
            ],
            "Comments": [
                "Request": Contracts.Comments.Request.keyDictionary,
                "Response": Contracts.Comments.Response.keyDictionary,
            ],
            "CommentsCounters": [
                "Request": Contracts.CommentsCounters.Request.keyDictionary,
                "Response": Contracts.CommentsCounters.Response.keyDictionary,
            ],
            "CreateComment": [
                "Request": Contracts.CreateComment.Request.keyDictionary,
                "Response": Contracts.CreateComment.Response.keyDictionary,
            ],
            "EditComment": [
                "Request": Contracts.EditComment.Request.keyDictionary,
                "Response": Contracts.EditComment.Response.keyDictionary,
            ],
            "LikeComment": [
                "Request": Contracts.LikeComment.Request.keyDictionary,
                "Response": Contracts.LikeComment.Response.keyDictionary,
            ],
            "PendingComments": [
                "Request": Contracts.PendingComments.Request.keyDictionary,
                "Response": Contracts.PendingComments.Response.keyDictionary,
            ],
            "PendingCommentsCount": [
                "Request": Contracts.PendingCommentsCount.Request.keyDictionary,
                "Response": Contracts.PendingCommentsCount.Response.keyDictionary,
            ],
            "RejectComment": [
                "Request": Contracts.RejectComment.Request.keyDictionary,
                "Response": Contracts.RejectComment.Response.keyDictionary,
            ],
            "UpdateUserAccessLevel": [
                "Request": Contracts.UpdateUserAccessLevel.Request.keyDictionary,
                "Response": Contracts.UpdateUserAccessLevel.Response.keyDictionary,
            ],
            "UserInfo": [
                "Request": Contracts.UserInfo.Request.keyDictionary,
                "Response": Contracts.UserInfo.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Quorum.Contracts {
    typealias FieldMapping = Services.Shared.FieldMapping
    typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    typealias CharacterInfo = Services.Shared.CharacterInfo
    typealias EventRequest = Services.Shared.EventRequest
    typealias UserSignupRequest = Services.Shared.UserSignupRequest
    typealias NodeInfo = Services.Shared.NodeInfo
    typealias PingRequest = Services.Shared.PingRequest
    typealias PingResponse = Services.Shared.PingResponse
    typealias CheckinRequest = Services.Shared.CheckinRequest
    typealias CheckinResponse = Services.Shared.CheckinResponse
    typealias LoginRequest = Services.Shared.LoginRequest
    typealias LoginResponse = Services.Shared.LoginResponse
    typealias CommentUserInfo = Services.Shared.CommentUserInfo
    typealias Comment = Services.Shared.Comment
    typealias User = Services.Shared.User

    enum DeleteComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "DeleteComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum UndeleteComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "UndeleteComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum HideComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "HideComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum UnhideComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "UnhideComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum ApproveComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "ApproveComment"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum Comments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "Comments"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let IDPost: String
            public let session: LGNC.Entity.Cookie?
            public let portal: LGNC.Entity.Cookie?
            public let author: LGNC.Entity.Cookie?

            public init(
                IDPost: String,
                session: LGNC.Entity.Cookie? = nil,
                portal: LGNC.Entity.Cookie? = nil,
                author: LGNC.Entity.Cookie? = nil
            ) {
                self.IDPost = IDPost
                self.session = session
                self.portal = portal
                self.author = author
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "IDPost",
                        "session",
                        "portal",
                        "author",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let IDPost: String? = try? (self.extract(param: "IDPost", from: dictionary) as String)
                let session: LGNC.Entity.Cookie??
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie??
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie??
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "IDPost": eventLoop
                        .submit {
                            guard let _ = IDPost else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "session": eventLoop
                        .submit {
                            guard let session = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if session == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let portal = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if portal == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let author = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if author == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            IDPost: IDPost!,
                            session: session!,
                            portal: portal!,
                            author: author!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    session: try Request.extract(param: "session", from: dictionary, isOptional: true),
                    portal: try Request.extract(param: "portal", from: dictionary, isOptional: true),
                    author: try Request.extract(param: "author", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let comments: [Services.Shared.Comment]

            public init(comments: [Services.Shared.Comment]) {
                self.comments = comments
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "comments",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let comments: [Services.Shared.Comment]? = try? (self.extract(param: "comments", from: dictionary) as [Services.Shared.Comment])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "comments": eventLoop
                        .submit {
                            guard let _ = comments else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            comments: comments!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }

        }
    }

    enum CommentsCounters: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "CommentsCounters"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let IDs: [String]

            public init(IDs: [String]) {
                self.IDs = IDs
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "IDs",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let IDs: [String]? = try? (self.extract(param: "IDs", from: dictionary) as [String])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "IDs": eventLoop
                        .submit {
                            guard let _ = IDs else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            IDs: IDs!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDs: try Request.extract(param: "IDs", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("IDs"): try self.encode(self.IDs),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let counters: [String:Int]

            public init(counters: [String:Int]) {
                self.counters = counters
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "counters",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let counters: [String:Int]? = try? (self.extract(param: "counters", from: dictionary) as [String:Int])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "counters": eventLoop
                        .submit {
                            guard let _ = counters else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            counters: counters!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    counters: try Response.extract(param: "counters", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("counters"): try self.encode(self.counters),
                ]
            }

        }
    }

    enum CreateComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "CreateComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDPostClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDPostAllowedValues>.Callback? = nil
            private static var validatorIDReplyCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDReplyCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDPostAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case PostNotFound = "Post not found"
                case PostIsReadOnly = "Post is read only"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .PostNotFound: return (code: 404, message: self.rawValue)
                        case .PostIsReadOnly: return (code: 403, message: self.rawValue)
                    }
                }
            }

            public enum CallbackValidatorIDReplyCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case ReplyingCommentNotFound = "Replying comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .ReplyingCommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDPost: String
            public let IDReplyComment: Int?
            public let body: String

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDPost: String,
                IDReplyComment: Int? = nil,
                body: String
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDPost = IDPost
                self.IDReplyComment = IDReplyComment
                self.body = body
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDPost",
                        "IDReplyComment",
                        "body",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDPost: String? = try? (self.extract(param: "IDPost", from: dictionary) as String)
                let IDReplyComment: Int?? = try? (self.extract(param: "IDReplyComment", from: dictionary, isOptional: true) as Int?)
                let body: String? = try? (self.extract(param: "body", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDPost": eventLoop
                        .submit {
                            guard let _ = IDPost else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDPostClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDPostAllowedValues>(callback: validator).validate(
                                IDPost!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                    "IDReplyComment": eventLoop
                        .submit {
                            guard let IDReplyComment = IDReplyComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if IDReplyComment == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        }.flatMap {
                            guard let IDReplyComment = IDReplyComment, let validator = self.validatorIDReplyCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDReplyCommentAllowedValues>(callback: validator).validate(
                                IDReplyComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                    "body": eventLoop
                        .submit {
                            guard let _ = body else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(body!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }
                        .flatMap {
                            if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(body!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDPost: IDPost!,
                            IDReplyComment: IDReplyComment!,
                            body: body!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDPost: try Request.extract(param: "IDPost", from: dictionary),
                    IDReplyComment: try Request.extract(param: "IDReplyComment", from: dictionary, isOptional: true),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDPost"): try self.encode(self.IDPost),
                    self.getDictionaryKey("IDReplyComment"): try self.encode(self.IDReplyComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIDPost(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDPostAllowedValues>.Callback
            ) {
                self.validatorIDPostClosure = callback
            }

            public static func validateIDReplyComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDReplyCommentAllowedValues>.Callback
            ) {
                self.validatorIDReplyCommentClosure = callback
            }

        }
    }

    enum EditComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = Services.Shared.Comment

        public static let URI = "EditComment"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = [ .MsgPack ]

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int
            public let body: String

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int,
                body: String
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
                self.body = body
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                        "body",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)
                let body: String? = try? (self.extract(param: "body", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                    "body": eventLoop
                        .submit {
                            guard let _ = body else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.Length.Min(length: 3, message: "Too short comment").validate(body!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }
                        .flatMap {
                            if let error = Validation.Length.Max(length: 4000, message: "Comment must be less than 4000 characters long").validate(body!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!,
                            body: body!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary),
                    body: try Request.extract(param: "body", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                    self.getDictionaryKey("body"): try self.encode(self.body),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum LikeComment: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "LikeComment"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let likes: Int

            public init(likes: Int) {
                self.likes = likes
            }

            public static func await(likes likesFuture: EventLoopFuture<Int>) -> EventLoopFuture<Response> {
                likesFuture.eventLoop.makeSucceededFuture(()).flatMap { () in
                    likesFuture.map { likes in (likes) }
                }
                .map { (likes) in
                    Response(
                        likes: likes
                    )
                }
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "likes",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let likes: Int? = try? (self.extract(param: "likes", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "likes": eventLoop
                        .submit {
                            guard let _ = likes else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            likes: likes!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    likes: try Response.extract(param: "likes", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("likes"): try self.encode(self.likes),
                ]
            }

        }
    }

    enum PendingComments: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "PendingComments"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie
            ) {
                self.session = session
                self.portal = portal
                self.author = author
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let comments: [Services.Shared.Comment]

            public init(comments: [Services.Shared.Comment]) {
                self.comments = comments
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "comments",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let comments: [Services.Shared.Comment]? = try? (self.extract(param: "comments", from: dictionary) as [Services.Shared.Comment])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "comments": eventLoop
                        .submit {
                            guard let _ = comments else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            comments: comments!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    comments: try Response.extract(param: "comments", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("comments"): try self.encode(self.comments),
                ]
            }

        }
    }

    enum PendingCommentsCount: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "PendingCommentsCount"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie
            ) {
                self.session = session
                self.portal = portal
                self.author = author
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let count: Int

            public init(count: Int) {
                self.count = count
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "count",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let count: Int? = try? (self.extract(param: "count", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "count": eventLoop
                        .submit {
                            guard let _ = count else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            count: count!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    count: try Response.extract(param: "count", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("count"): try self.encode(self.count),
                ]
            }

        }
    }

    enum RejectComment: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RejectComment"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            private static var validatorIDCommentClosure: Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback? = nil

            public enum CallbackValidatorIDCommentAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = Int

                case CommentNotFound = "Comment not found"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .CommentNotFound: return (code: 404, message: self.rawValue)
                    }
                }
            }

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDComment: Int

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDComment: Int
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDComment = IDComment
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDComment",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDComment: Int? = try? (self.extract(param: "IDComment", from: dictionary) as Int)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDComment": eventLoop
                        .submit {
                            guard let _ = IDComment else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            guard let validator = self.validatorIDCommentClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>(callback: validator).validate(
                                IDComment!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDComment: IDComment!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDComment: try Request.extract(param: "IDComment", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDComment"): try self.encode(self.IDComment),
                ]
            }

            public static func validateIDComment(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorIDCommentAllowedValues>.Callback
            ) {
                self.validatorIDCommentClosure = callback
            }

        }
    }

    enum UpdateUserAccessLevel: Contract {
        public typealias ParentService = Services.Quorum

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "UpdateUserAccessLevel"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let author: LGNC.Entity.Cookie
            public let IDUser: String
            public let accessLevel: String

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                author: LGNC.Entity.Cookie,
                IDUser: String,
                accessLevel: String
            ) {
                self.session = session
                self.portal = portal
                self.author = author
                self.IDUser = IDUser
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "author",
                        "IDUser",
                        "accessLevel",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let session: LGNC.Entity.Cookie?
                do {
                    session = try self.extractCookie(param: "session", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let portal: LGNC.Entity.Cookie?
                do {
                    portal = try self.extractCookie(param: "portal", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let author: LGNC.Entity.Cookie?
                do {
                    author = try self.extractCookie(param: "author", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)
                let accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "session": eventLoop
                        .submit {
                            guard let _ = session else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "portal": eventLoop
                        .submit {
                            guard let _ = portal else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "author": eventLoop
                        .submit {
                            guard let _ = author else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "IDUser": eventLoop
                        .submit {
                            guard let _ = IDUser else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.UUID().validate(IDUser!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                    "accessLevel": eventLoop
                        .submit {
                            guard let _ = accessLevel else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.In(allowedValues: ["User", "PowerUser", "Moderator", "Admin"]).validate(accessLevel!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            session: session!,
                            portal: portal!,
                            author: author!,
                            IDUser: IDUser!,
                            accessLevel: accessLevel!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    author: try Request.extract(param: "author", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    accessLevel: try Request.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("author"): try self.encode(self.author),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }

        }
    }

    enum UserInfo: Contract {
        public typealias ParentService = Services.Quorum

        public static let URI = "UserInfo"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let IDUser: String

            public init(IDUser: String) {
                self.IDUser = IDUser
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "IDUser",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "IDUser": eventLoop
                        .submit {
                            guard let _ = IDUser else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.UUID().validate(IDUser!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            IDUser: IDUser!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDUser: try Request.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let accessLevel: String

            public init(accessLevel: String) {
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "accessLevel",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "accessLevel": eventLoop
                        .submit {
                            guard let _ = accessLevel else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }.flatMap {
                            if let error = Validation.In(allowedValues: ["User", "PowerUser", "Moderator", "Admin"]).validate(accessLevel!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            accessLevel: accessLevel!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    accessLevel: try Response.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }

        }
    }
}