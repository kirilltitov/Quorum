/**
 * This file has been autogenerated by LGNC assembler on 2019-07-05 15:55:09.650374.
 * All changes will be lost on next assembly.
 */

import Entita
import Foundation
import LGNC
import LGNCore
import LGNP
import LGNS
import NIO

public extension Services {
    enum Author: Service {
        public enum Contracts {}

        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public static let info: [String: String] = [
            "ElderName": "hudruk",
        ]
        public static var guaranteeStatuses: [String: Bool] = [
            Contracts.Checkin.URI: Contracts.Checkin.isGuaranteed,
            Contracts.Ping.URI: Contracts.Ping.isGuaranteed,
            Contracts.RaiseEvent.URI: Contracts.RaiseEvent.isGuaranteed,
            Contracts.AnnounceEvent.URI: Contracts.AnnounceEvent.isGuaranteed,
            Contracts.Login.URI: Contracts.Login.isGuaranteed,
            Contracts.InternalLogin.URI: Contracts.InternalLogin.isGuaranteed,
            Contracts.UserInfo.URI: Contracts.UserInfo.isGuaranteed,
            Contracts.UserInfoInternal.URI: Contracts.UserInfoInternal.isGuaranteed,
            Contracts.Authenticate.URI: Contracts.Authenticate.isGuaranteed,
            Contracts.ChangePassword.URI: Contracts.ChangePassword.isGuaranteed,
            Contracts.ValidateEmail.URI: Contracts.ValidateEmail.isGuaranteed,
            Contracts.ResendValidationEmail.URI: Contracts.ResendValidationEmail.isGuaranteed,
            Contracts.ResetPasswordStep1.URI: Contracts.ResetPasswordStep1.isGuaranteed,
            Contracts.ResetPasswordStep2.URI: Contracts.ResetPasswordStep2.isGuaranteed,
            Contracts.InternalSignup.URI: Contracts.InternalSignup.isGuaranteed,
            Contracts.Logout.URI: Contracts.Logout.isGuaranteed,
            Contracts.Signup.URI: Contracts.Signup.isGuaranteed,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.isGuaranteed,
        ]

        public static let contractMap: [String: SomeContract.Type] = [
            Contracts.Checkin.URI: Contracts.Checkin.self,
            Contracts.Ping.URI: Contracts.Ping.self,
            Contracts.RaiseEvent.URI: Contracts.RaiseEvent.self,
            Contracts.AnnounceEvent.URI: Contracts.AnnounceEvent.self,
            Contracts.Login.URI: Contracts.Login.self,
            Contracts.InternalLogin.URI: Contracts.InternalLogin.self,
            Contracts.UserInfo.URI: Contracts.UserInfo.self,
            Contracts.UserInfoInternal.URI: Contracts.UserInfoInternal.self,
            Contracts.Authenticate.URI: Contracts.Authenticate.self,
            Contracts.ChangePassword.URI: Contracts.ChangePassword.self,
            Contracts.ValidateEmail.URI: Contracts.ValidateEmail.self,
            Contracts.ResendValidationEmail.URI: Contracts.ResendValidationEmail.self,
            Contracts.ResetPasswordStep1.URI: Contracts.ResetPasswordStep1.self,
            Contracts.ResetPasswordStep2.URI: Contracts.ResetPasswordStep2.self,
            Contracts.InternalSignup.URI: Contracts.InternalSignup.self,
            Contracts.Logout.URI: Contracts.Logout.self,
            Contracts.Signup.URI: Contracts.Signup.self,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.self,
        ]

        public static func guaranteeCheckinContract(_ guaranteeClosure: @escaping Contracts.Checkin.FutureClosureWithMeta) {
            Contracts.Checkin.guarantee(guaranteeClosure)
        }

        public static func guaranteeCheckinContract(_ guaranteeClosure: @escaping Contracts.Checkin.FutureClosure) {
            Contracts.Checkin.guarantee(guaranteeClosure)
        }

        public static func guaranteeCheckinContract(_ guaranteeClosure: @escaping Contracts.Checkin.NonFutureClosureWithMeta) {
            Contracts.Checkin.guarantee(guaranteeClosure)
        }

        public static func guaranteeCheckinContract(_ guaranteeClosure: @escaping Contracts.Checkin.NonFutureClosure) {
            Contracts.Checkin.guarantee(guaranteeClosure)
        }

        public static func guaranteePingContract(_ guaranteeClosure: @escaping Contracts.Ping.FutureClosureWithMeta) {
            Contracts.Ping.guarantee(guaranteeClosure)
        }

        public static func guaranteePingContract(_ guaranteeClosure: @escaping Contracts.Ping.FutureClosure) {
            Contracts.Ping.guarantee(guaranteeClosure)
        }

        public static func guaranteePingContract(_ guaranteeClosure: @escaping Contracts.Ping.NonFutureClosureWithMeta) {
            Contracts.Ping.guarantee(guaranteeClosure)
        }

        public static func guaranteePingContract(_ guaranteeClosure: @escaping Contracts.Ping.NonFutureClosure) {
            Contracts.Ping.guarantee(guaranteeClosure)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeClosure: @escaping Contracts.RaiseEvent.FutureClosureWithMeta) {
            Contracts.RaiseEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeClosure: @escaping Contracts.RaiseEvent.FutureClosure) {
            Contracts.RaiseEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeClosure: @escaping Contracts.RaiseEvent.NonFutureClosureWithMeta) {
            Contracts.RaiseEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeClosure: @escaping Contracts.RaiseEvent.NonFutureClosure) {
            Contracts.RaiseEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeClosure: @escaping Contracts.AnnounceEvent.FutureClosureWithMeta) {
            Contracts.AnnounceEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeClosure: @escaping Contracts.AnnounceEvent.FutureClosure) {
            Contracts.AnnounceEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeClosure: @escaping Contracts.AnnounceEvent.NonFutureClosureWithMeta) {
            Contracts.AnnounceEvent.guarantee(guaranteeClosure)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeClosure: @escaping Contracts.AnnounceEvent.NonFutureClosure) {
            Contracts.AnnounceEvent.guarantee(guaranteeClosure)
        }

        public static func executeCheckinContract(
            at address: LGNCore.Address,
            with request: Contracts.Checkin.Request,
            using client: LGNCClient
        ) -> Future<Contracts.Checkin.Response> {
            return Contracts.Checkin.execute(at: address, with: request, using: client)
        }

        public static func executePingContract(
            at address: LGNCore.Address,
            with request: Contracts.Ping.Request,
            using client: LGNCClient
        ) -> Future<Contracts.Ping.Response> {
            return Contracts.Ping.execute(at: address, with: request, using: client)
        }

        public static func executeRaiseEventContract(
            at address: LGNCore.Address,
            with request: Contracts.RaiseEvent.Request,
            using client: LGNCClient
        ) -> Future<Contracts.RaiseEvent.Response> {
            return Contracts.RaiseEvent.execute(at: address, with: request, using: client)
        }

        public static func executeAnnounceEventContract(
            at address: LGNCore.Address,
            with request: Contracts.AnnounceEvent.Request,
            using client: LGNCClient
        ) -> Future<Contracts.AnnounceEvent.Response> {
            return Contracts.AnnounceEvent.execute(at: address, with: request, using: client)
        }

        public static func validateContractCheckinFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Checkin.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Checkin.Request.validateName(callback)
        }

        public static func validateContractPingFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Ping.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Ping.Request.validateName(callback)
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Checkin": [
                "Request": Contracts.Checkin.Request.keyDictionary,
                "Response": Contracts.Checkin.Response.keyDictionary,
            ],
            "Ping": [
                "Request": Contracts.Ping.Request.keyDictionary,
                "Response": Contracts.Ping.Response.keyDictionary,
            ],
            "RaiseEvent": [
                "Request": Contracts.RaiseEvent.Request.keyDictionary,
                "Response": Contracts.RaiseEvent.Response.keyDictionary,
            ],
            "AnnounceEvent": [
                "Request": Contracts.AnnounceEvent.Request.keyDictionary,
                "Response": Contracts.AnnounceEvent.Response.keyDictionary,
            ],
            "Login": [
                "Request": Contracts.Login.Request.keyDictionary,
                "Response": Contracts.Login.Response.keyDictionary,
            ],
            "InternalLogin": [
                "Request": Contracts.InternalLogin.Request.keyDictionary,
                "Response": Contracts.InternalLogin.Response.keyDictionary,
            ],
            "UserInfo": [
                "Request": Contracts.UserInfo.Request.keyDictionary,
                "Response": Contracts.UserInfo.Response.keyDictionary,
            ],
            "UserInfoInternal": [
                "Request": Contracts.UserInfoInternal.Request.keyDictionary,
                "Response": Contracts.UserInfoInternal.Response.keyDictionary,
            ],
            "Authenticate": [
                "Request": Contracts.Authenticate.Request.keyDictionary,
                "Response": Contracts.Authenticate.Response.keyDictionary,
            ],
            "ChangePassword": [
                "Request": Contracts.ChangePassword.Request.keyDictionary,
                "Response": Contracts.ChangePassword.Response.keyDictionary,
            ],
            "ValidateEmail": [
                "Request": Contracts.ValidateEmail.Request.keyDictionary,
                "Response": Contracts.ValidateEmail.Response.keyDictionary,
            ],
            "ResendValidationEmail": [
                "Request": Contracts.ResendValidationEmail.Request.keyDictionary,
                "Response": Contracts.ResendValidationEmail.Response.keyDictionary,
            ],
            "ResetPasswordStep1": [
                "Request": Contracts.ResetPasswordStep1.Request.keyDictionary,
                "Response": Contracts.ResetPasswordStep1.Response.keyDictionary,
            ],
            "ResetPasswordStep2": [
                "Request": Contracts.ResetPasswordStep2.Request.keyDictionary,
                "Response": Contracts.ResetPasswordStep2.Response.keyDictionary,
            ],
            "InternalSignup": [
                "Request": Contracts.InternalSignup.Request.keyDictionary,
                "Response": Contracts.InternalSignup.Response.keyDictionary,
            ],
            "Logout": [
                "Request": Contracts.Logout.Request.keyDictionary,
                "Response": Contracts.Logout.Response.keyDictionary,
            ],
            "Signup": [
                "Request": Contracts.Signup.Request.keyDictionary,
                "Response": Contracts.Signup.Response.keyDictionary,
            ],
            "UpdateUserAccessLevel": [
                "Request": Contracts.UpdateUserAccessLevel.Request.keyDictionary,
                "Response": Contracts.UpdateUserAccessLevel.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Author.Contracts {
    typealias FieldMapping = Services.Shared.FieldMapping
    typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    typealias CharacterInfo = Services.Shared.CharacterInfo
    typealias EventRequest = Services.Shared.EventRequest
    typealias UserSignupRequest = Services.Shared.UserSignupRequest
    typealias NodeInfo = Services.Shared.NodeInfo
    typealias PingRequest = Services.Shared.PingRequest
    typealias PingResponse = Services.Shared.PingResponse
    typealias CheckinRequest = Services.Shared.CheckinRequest
    typealias CheckinResponse = Services.Shared.CheckinResponse
    typealias LoginRequest = Services.Shared.LoginRequest
    typealias LoginResponse = Services.Shared.LoginResponse
    typealias CommentUserInfo = Services.Shared.CommentUserInfo
    typealias Empty = Services.Shared.Empty
    typealias Comment = Services.Shared.Comment
    typealias User = Services.Shared.User

    enum Checkin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.CheckinRequest
        public typealias Response = Services.Shared.CheckinResponse

        public static let URI = "Checkin"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum Ping: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.PingRequest
        public typealias Response = Services.Shared.PingResponse

        public static let URI = "Ping"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum RaiseEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RaiseEvent"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum AnnounceEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "AnnounceEvent"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum Login: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "Login"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum InternalLogin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "InternalLogin"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum UserInfo: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "UserInfo"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
            ]

            public let ID: String

            public init(
                ID: String
            ) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "ID": eventLoop.submit {
                        guard let _ = ID else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(ID!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            ID: ID!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
                "username": "c",
                "sex": "d",
                "isBanned": "e",
                "accessLevel": "f",
            ]

            public let ID: String
            public var username: String
            public let sex: String
            public var isBanned: Bool
            public let accessLevel: String

            public init(
                ID: String,
                username: String,
                sex: String,
                isBanned: Bool,
                accessLevel: String
            ) {
                self.ID = ID
                self.username = username
                self.sex = sex
                self.isBanned = isBanned
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                let ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)
                let username: String? = try? (self.extract(param: "username", from: dictionary) as String)
                let sex: String? = try? (self.extract(param: "sex", from: dictionary) as String)
                let isBanned: Bool? = try? (self.extract(param: "isBanned", from: dictionary) as Bool)
                let accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "ID": eventLoop.submit {
                        guard let _ = ID else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(ID!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "username": eventLoop.submit {
                        guard let _ = username else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "sex": eventLoop.submit {
                        guard let _ = sex else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(sex!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "isBanned": eventLoop.submit {
                        guard let _ = isBanned else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "accessLevel": eventLoop.submit {
                        guard let _ = accessLevel else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.In(allowedValues: ["User", "Moderator", "Admin"]).validate(accessLevel!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            ID: ID!,
                            username: username!,
                            sex: sex!,
                            isBanned: isBanned!,
                            accessLevel: accessLevel!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Response.extract(param: "ID", from: dictionary),
                    username: try Response.extract(param: "username", from: dictionary),
                    sex: try Response.extract(param: "sex", from: dictionary),
                    isBanned: try Response.extract(param: "isBanned", from: dictionary),
                    accessLevel: try Response.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("isBanned"): try self.encode(self.isBanned),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }
        }
    }

    enum UserInfoInternal: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.User

        public static let URI = "UserInfoInternal"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
            ]

            public let ID: String

            public init(
                ID: String
            ) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "ID": eventLoop.submit {
                        guard let _ = ID else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(ID!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            ID: ID!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }
        }
    }

    enum Authenticate: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "Authenticate"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "portal": "b",
                "token": "c",
            ]

            public let portal: String
            public let token: String

            public init(
                portal: String,
                token: String
            ) {
                self.portal = portal
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let portal: String? = try? (self.extract(param: "portal", from: dictionary) as String)
                let token: String? = try? (self.extract(param: "token", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "portal": eventLoop.submit {
                        guard let _ = portal else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "token": eventLoop.submit {
                        guard let _ = token else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            portal: portal!,
                            token: token!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    portal: try Request.extract(param: "portal", from: dictionary),
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "IDUser": "b",
            ]

            public let IDUser: String?

            public init(
                IDUser: String? = nil
            ) {
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                let IDUser: String?? = try? (self.extract(param: "IDUser", from: dictionary, isOptional: true) as String?)

                let validatorFutures: [String: Future<Void>] = [
                    "IDUser": eventLoop.submit {
                        let _: String? = try (self.extract(param: "IDUser", from: dictionary, isOptional: true) as String?)
                        guard let IDUser = IDUser else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                        if IDUser == nil {
                            throw Validation.Error.SkipMissingOptionalValueValidators()
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            IDUser: IDUser!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDUser: try Response.extract(param: "IDUser", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }
        }
    }

    enum ChangePassword: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ChangePassword"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
                "password1": "c",
                "password2": "d",
            ]

            public let token: String
            public let password1: String
            public let password2: String

            public init(
                token: String,
                password1: String,
                password2: String
            ) {
                self.token = token
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let token: String? = try? (self.extract(param: "token", from: dictionary) as String)
                let password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "token": eventLoop.submit {
                        guard let _ = token else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "password1": eventLoop.submit {
                        guard let _ = password1 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "password2": eventLoop.submit {
                        guard let _ = password2 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Identical(right: password1!, message: "Passwords must match").validate(password2!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            token: token!,
                            password1: password1!,
                            password2: password2!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }
        }
    }

    enum ValidateEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "ValidateEmail"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "node": "b",
                "validationToken": "c",
                "IDUser": "d",
            ]

            public let node: String
            public let validationToken: String
            public let IDUser: String

            public init(
                node: String,
                validationToken: String,
                IDUser: String
            ) {
                self.node = node
                self.validationToken = validationToken
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let node: String? = try? (self.extract(param: "node", from: dictionary) as String)
                let validationToken: String? = try? (self.extract(param: "validationToken", from: dictionary) as String)
                let IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "node": eventLoop.submit {
                        guard let _ = node else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "validationToken": eventLoop.submit {
                        guard let _ = validationToken else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "IDUser": eventLoop.submit {
                        guard let _ = IDUser else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(IDUser!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            node: node!,
                            validationToken: validationToken!,
                            IDUser: IDUser!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    node: try Request.extract(param: "node", from: dictionary),
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("node"): try self.encode(self.node),
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }
        }
    }

    enum ResendValidationEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ResendValidationEmail"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "email": "b",
                "recaptchaToken": "c",
            ]

            public let email: String
            public let recaptchaToken: String

            public init(
                email: String,
                recaptchaToken: String
            ) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "email": eventLoop.submit {
                        guard let _ = email else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "recaptchaToken": eventLoop.submit {
                        guard let _ = recaptchaToken else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            email: email!,
                            recaptchaToken: recaptchaToken!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }
        }
    }

    enum ResetPasswordStep1: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ResetPasswordStep1"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "email": "b",
                "recaptchaToken": "c",
            ]

            public let email: String
            public let recaptchaToken: String

            public init(
                email: String,
                recaptchaToken: String
            ) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "email": eventLoop.submit {
                        guard let _ = email else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "recaptchaToken": eventLoop.submit {
                        guard let _ = recaptchaToken else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            email: email!,
                            recaptchaToken: recaptchaToken!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }
        }
    }

    enum ResetPasswordStep2: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "ResetPasswordStep2"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "validationToken": "b",
                "IDUser": "c",
                "password1": "d",
                "password2": "e",
            ]

            public let validationToken: String
            public let IDUser: String
            public let password1: String
            public let password2: String

            public init(
                validationToken: String,
                IDUser: String,
                password1: String,
                password2: String
            ) {
                self.validationToken = validationToken
                self.IDUser = IDUser
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let validationToken: String? = try? (self.extract(param: "validationToken", from: dictionary) as String)
                let IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)
                let password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "validationToken": eventLoop.submit {
                        guard let _ = validationToken else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "IDUser": eventLoop.submit {
                        guard let _ = IDUser else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(IDUser!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "password1": eventLoop.submit {
                        guard let _ = password1 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "password2": eventLoop.submit {
                        guard let _ = password2 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Identical(right: password1!, message: "Passwords must match").validate(password2!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            validationToken: validationToken!,
                            IDUser: IDUser!,
                            password1: password1!,
                            password2: password2!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }
        }
    }

    enum InternalSignup: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "InternalSignup"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public enum CallbackValidatorUsernameAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenUsernameAlreadyExists = "User with given username already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .UserWithGivenUsernameAlreadyExists: return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public enum CallbackValidatorEmailAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenEmailAlreadyExists = "User with given email already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .UserWithGivenEmailAlreadyExists: return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "username": "b",
                "email": "c",
                "password1": "d",
                "password2": "e",
                "sex": "f",
                "language": "g",
                "recaptchaToken": "h",
                "ip": "i",
                "userAgent": "j",
                "country": "k",
            ]

            public let username: String
            public let email: String
            public let password1: String
            public let password2: String
            public let sex: String
            public let language: String
            public let recaptchaToken: String
            public let ip: String
            public let userAgent: String
            public let country: String

            private static var validatorUsernameClosure: Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback?
            private static var validatorEmailClosure: Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback?

            public init(
                username: String,
                email: String,
                password1: String,
                password2: String,
                sex: String,
                language: String,
                recaptchaToken: String,
                ip: String,
                userAgent: String,
                country: String
            ) {
                self.username = username
                self.email = email
                self.password1 = password1
                self.password2 = password2
                self.sex = sex
                self.language = language
                self.recaptchaToken = recaptchaToken
                self.ip = ip
                self.userAgent = userAgent
                self.country = country
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let username: String? = try? (self.extract(param: "username", from: dictionary) as String)
                let email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)
                let sex: String? = try? (self.extract(param: "sex", from: dictionary) as String)
                let language: String? = try? (self.extract(param: "language", from: dictionary) as String)
                let recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)
                let ip: String? = try? (self.extract(param: "ip", from: dictionary) as String)
                let userAgent: String? = try? (self.extract(param: "userAgent", from: dictionary) as String)
                let country: String? = try? (self.extract(param: "country", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "username": eventLoop.submit {
                        guard let _ = username else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Regexp(pattern: "^[a-zA-Zа-яА-Я0-9_\\- ]+$", message: "Username must only consist of letters, numbers and underscores").validate(username!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        if let error = Validation.Length.Min(length: 3).validate(username!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        if let error = Validation.Length.Max(length: 24).validate(username!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        guard let validator = self.validatorUsernameClosure else {
                            return eventLoop.makeSucceededFuture()
                        }
                        return Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>(callback: validator).validate(
                            username!,
                            requestInfo.locale,
                            on: eventLoop
                        ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                    },
                    "email": eventLoop.submit {
                        guard let _ = email else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Regexp(pattern: "^.+@.+\\..+$", message: "Invalid email format").validate(email!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        guard let validator = self.validatorEmailClosure else {
                            return eventLoop.makeSucceededFuture()
                        }
                        return Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>(callback: validator).validate(
                            email!,
                            requestInfo.locale,
                            on: eventLoop
                        ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                    },
                    "password1": eventLoop.submit {
                        guard let _ = password1 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    }.flatMap {
                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(password1!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "password2": eventLoop.submit {
                        guard let _ = password2 else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.Identical(right: password1!, message: "Passwords must match").validate(password2!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "sex": eventLoop.submit {
                        guard let _ = sex else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(sex!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "language": eventLoop.submit {
                        guard let _ = language else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.In(allowedValues: ["en", "ru"]).validate(language!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "recaptchaToken": eventLoop.submit {
                        guard let _ = recaptchaToken else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "ip": eventLoop.submit {
                        guard let _ = ip else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "userAgent": eventLoop.submit {
                        guard let _ = userAgent else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "country": eventLoop.submit {
                        guard let _ = country else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            username: username!,
                            email: email!,
                            password1: password1!,
                            password2: password2!,
                            sex: sex!,
                            language: language!,
                            recaptchaToken: recaptchaToken!,
                            ip: ip!,
                            userAgent: userAgent!,
                            country: country!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    username: try Request.extract(param: "username", from: dictionary),
                    email: try Request.extract(param: "email", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary),
                    sex: try Request.extract(param: "sex", from: dictionary),
                    language: try Request.extract(param: "language", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary),
                    ip: try Request.extract(param: "ip", from: dictionary),
                    userAgent: try Request.extract(param: "userAgent", from: dictionary),
                    country: try Request.extract(param: "country", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("language"): try self.encode(self.language),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                    self.getDictionaryKey("ip"): try self.encode(self.ip),
                    self.getDictionaryKey("userAgent"): try self.encode(self.userAgent),
                    self.getDictionaryKey("country"): try self.encode(self.country),
                ]
            }

            public static func validateUsername(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback
            ) {
                self.validatorUsernameClosure = callback
            }

            public static func validateEmail(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback
            ) {
                self.validatorEmailClosure = callback
            }
        }
    }

    enum Logout: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Logout"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
                "portal": "c",
            ]

            public let token: String
            public let portal: String

            public init(
                token: String,
                portal: String
            ) {
                self.token = token
                self.portal = portal
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let token: String? = try? (self.extract(param: "token", from: dictionary) as String)
                let portal: String? = try? (self.extract(param: "portal", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "token": eventLoop.submit {
                        guard let _ = token else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "portal": eventLoop.submit {
                        guard let _ = portal else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            token: token!,
                            portal: portal!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                ]
            }
        }
    }

    enum Signup: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.UserSignupRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Signup"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private
    }

    enum UpdateUserAccessLevel: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "UpdateUserAccessLevel"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.all

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
                "portal": "c",
                "IDUser": "d",
                "accessLevel": "e",
            ]

            public let token: String
            public let portal: String
            public let IDUser: String
            public let accessLevel: String

            public init(
                token: String,
                portal: String,
                IDUser: String,
                accessLevel: String
            ) {
                self.token = token
                self.portal = portal
                self.IDUser = IDUser
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                let token: String? = try? (self.extract(param: "token", from: dictionary) as String)
                let portal: String? = try? (self.extract(param: "portal", from: dictionary) as String)
                let IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)
                let accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorFutures: [String: Future<Void>] = [
                    "token": eventLoop.submit {
                        guard let _ = token else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "portal": eventLoop.submit {
                        guard let _ = portal else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    },
                    "IDUser": eventLoop.submit {
                        guard let _ = IDUser else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.UUID().validate(IDUser!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                    "accessLevel": eventLoop.submit {
                        guard let _ = accessLevel else {
                            throw Validation.Error.MissingValue(requestInfo.locale)
                        }
                    }.flatMap {
                        if let error = Validation.In(allowedValues: ["User", "Moderator", "Admin"]).validate(accessLevel!, requestInfo.locale) {
                            return eventLoop.makeFailedFuture(error)
                        }
                        return eventLoop.makeSucceededFuture()
                    },
                ]

                return self
                    .reduce(validators: validatorFutures, requestInfo: requestInfo)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            token: token!,
                            portal: portal!,
                            IDUser: IDUser!,
                            accessLevel: accessLevel!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    accessLevel: try Request.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }
        }
    }
}
