/**
 * This file has been autogenerated by LGNC assembler on 2021-03-30 22:39:38 +0000 (1617143978.789007).
 * All changes will be lost on next assembly.
 */

import Foundation
import LGNCore
import LGNP
import LGNC
import LGNS
import Entita

public extension Services {
    enum Author: Service {
        public enum Contracts {}

        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public static let info: [String: String] = [
            "ElderName": "hudruk",
        ]

        public static var guaranteeStatuses: [String: Bool] = [
            Contracts.Checkin.URI: Contracts.Checkin.isGuaranteed,
            Contracts.Ping.URI: Contracts.Ping.isGuaranteed,
            Contracts.RaiseEvent.URI: Contracts.RaiseEvent.isGuaranteed,
            Contracts.AnnounceEvent.URI: Contracts.AnnounceEvent.isGuaranteed,
            Contracts.Login.URI: Contracts.Login.isGuaranteed,
            Contracts.InternalLogin.URI: Contracts.InternalLogin.isGuaranteed,
            Contracts.UserInfo.URI: Contracts.UserInfo.isGuaranteed,
            Contracts.UserInfoInternal.URI: Contracts.UserInfoInternal.isGuaranteed,
            Contracts.Authenticate.URI: Contracts.Authenticate.isGuaranteed,
            Contracts.ValidateEmail.URI: Contracts.ValidateEmail.isGuaranteed,
            Contracts.ResendValidationEmail.URI: Contracts.ResendValidationEmail.isGuaranteed,
            Contracts.PasswordResetStep1.URI: Contracts.PasswordResetStep1.isGuaranteed,
            Contracts.PasswordResetStep2.URI: Contracts.PasswordResetStep2.isGuaranteed,
            Contracts.InternalSignup.URI: Contracts.InternalSignup.isGuaranteed,
            Contracts.Logout.URI: Contracts.Logout.isGuaranteed,
            Contracts.PasswordChange.URI: Contracts.PasswordChange.isGuaranteed,
            Contracts.Signup.URI: Contracts.Signup.isGuaranteed,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.isGuaranteed,
        ]

        public static let contractMap: [String: AnyContract.Type] = [
            Contracts.Checkin.URI: Contracts.Checkin.self,
            Contracts.Ping.URI: Contracts.Ping.self,
            Contracts.RaiseEvent.URI: Contracts.RaiseEvent.self,
            Contracts.AnnounceEvent.URI: Contracts.AnnounceEvent.self,
            Contracts.Login.URI: Contracts.Login.self,
            Contracts.InternalLogin.URI: Contracts.InternalLogin.self,
            Contracts.UserInfo.URI: Contracts.UserInfo.self,
            Contracts.UserInfoInternal.URI: Contracts.UserInfoInternal.self,
            Contracts.Authenticate.URI: Contracts.Authenticate.self,
            Contracts.ValidateEmail.URI: Contracts.ValidateEmail.self,
            Contracts.ResendValidationEmail.URI: Contracts.ResendValidationEmail.self,
            Contracts.PasswordResetStep1.URI: Contracts.PasswordResetStep1.self,
            Contracts.PasswordResetStep2.URI: Contracts.PasswordResetStep2.self,
            Contracts.InternalSignup.URI: Contracts.InternalSignup.self,
            Contracts.Logout.URI: Contracts.Logout.self,
            Contracts.PasswordChange.URI: Contracts.PasswordChange.self,
            Contracts.Signup.URI: Contracts.Signup.self,
            Contracts.UpdateUserAccessLevel.URI: Contracts.UpdateUserAccessLevel.self,
        ]

        public static func guaranteeCheckinContract(_ guaranteeBody: @escaping Contracts.Checkin.GuaranteeBodyWithMeta) {
            Contracts.Checkin.guarantee(guaranteeBody)
        }

        public static func guaranteeCheckinContract(_ guaranteeBody: @escaping Contracts.Checkin.GuaranteeBody) {
            Contracts.Checkin.guarantee(guaranteeBody)
        }

        public static func guaranteePingContract(_ guaranteeBody: @escaping Contracts.Ping.GuaranteeBodyWithMeta) {
            Contracts.Ping.guarantee(guaranteeBody)
        }

        public static func guaranteePingContract(_ guaranteeBody: @escaping Contracts.Ping.GuaranteeBody) {
            Contracts.Ping.guarantee(guaranteeBody)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeBody: @escaping Contracts.RaiseEvent.GuaranteeBodyWithMeta) {
            Contracts.RaiseEvent.guarantee(guaranteeBody)
        }

        public static func guaranteeRaiseEventContract(_ guaranteeBody: @escaping Contracts.RaiseEvent.GuaranteeBody) {
            Contracts.RaiseEvent.guarantee(guaranteeBody)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeBody: @escaping Contracts.AnnounceEvent.GuaranteeBodyWithMeta) {
            Contracts.AnnounceEvent.guarantee(guaranteeBody)
        }

        public static func guaranteeAnnounceEventContract(_ guaranteeBody: @escaping Contracts.AnnounceEvent.GuaranteeBody) {
            Contracts.AnnounceEvent.guarantee(guaranteeBody)
        }

        public static func executeCheckinContract(
            at address: LGNCore.Address,
            with request: Contracts.Checkin.Request,
            using client: LGNCClient
        ) async throws -> Contracts.Checkin.Response {
            try await Contracts.Checkin.execute(at: address, with: request, using: client)
        }

        public static func executePingContract(
            at address: LGNCore.Address,
            with request: Contracts.Ping.Request,
            using client: LGNCClient
        ) async throws -> Contracts.Ping.Response {
            try await Contracts.Ping.execute(at: address, with: request, using: client)
        }

        public static func executeRaiseEventContract(
            at address: LGNCore.Address,
            with request: Contracts.RaiseEvent.Request,
            using client: LGNCClient
        ) async throws -> Contracts.RaiseEvent.Response {
            try await Contracts.RaiseEvent.execute(at: address, with: request, using: client)
        }

        public static func executeAnnounceEventContract(
            at address: LGNCore.Address,
            with request: Contracts.AnnounceEvent.Request,
            using client: LGNCClient
        ) async throws -> Contracts.AnnounceEvent.Response {
            try await Contracts.AnnounceEvent.execute(at: address, with: request, using: client)
        }

        public static func validateContractCheckinFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Checkin.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Checkin.Request.validateName(callback)
        }

        public static func validateContractPingFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Ping.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Ping.Request.validateName(callback)
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Checkin": [
                "Request": Contracts.Checkin.Request.keyDictionary,
                "Response": Contracts.Checkin.Response.keyDictionary,
            ],
            "Ping": [
                "Request": Contracts.Ping.Request.keyDictionary,
                "Response": Contracts.Ping.Response.keyDictionary,
            ],
            "RaiseEvent": [
                "Request": Contracts.RaiseEvent.Request.keyDictionary,
                "Response": Contracts.RaiseEvent.Response.keyDictionary,
            ],
            "AnnounceEvent": [
                "Request": Contracts.AnnounceEvent.Request.keyDictionary,
                "Response": Contracts.AnnounceEvent.Response.keyDictionary,
            ],
            "Login": [
                "Request": Contracts.Login.Request.keyDictionary,
                "Response": Contracts.Login.Response.keyDictionary,
            ],
            "InternalLogin": [
                "Request": Contracts.InternalLogin.Request.keyDictionary,
                "Response": Contracts.InternalLogin.Response.keyDictionary,
            ],
            "UserInfo": [
                "Request": Contracts.UserInfo.Request.keyDictionary,
                "Response": Contracts.UserInfo.Response.keyDictionary,
            ],
            "UserInfoInternal": [
                "Request": Contracts.UserInfoInternal.Request.keyDictionary,
                "Response": Contracts.UserInfoInternal.Response.keyDictionary,
            ],
            "Authenticate": [
                "Request": Contracts.Authenticate.Request.keyDictionary,
                "Response": Contracts.Authenticate.Response.keyDictionary,
            ],
            "ValidateEmail": [
                "Request": Contracts.ValidateEmail.Request.keyDictionary,
                "Response": Contracts.ValidateEmail.Response.keyDictionary,
            ],
            "ResendValidationEmail": [
                "Request": Contracts.ResendValidationEmail.Request.keyDictionary,
                "Response": Contracts.ResendValidationEmail.Response.keyDictionary,
            ],
            "PasswordResetStep1": [
                "Request": Contracts.PasswordResetStep1.Request.keyDictionary,
                "Response": Contracts.PasswordResetStep1.Response.keyDictionary,
            ],
            "PasswordResetStep2": [
                "Request": Contracts.PasswordResetStep2.Request.keyDictionary,
                "Response": Contracts.PasswordResetStep2.Response.keyDictionary,
            ],
            "InternalSignup": [
                "Request": Contracts.InternalSignup.Request.keyDictionary,
                "Response": Contracts.InternalSignup.Response.keyDictionary,
            ],
            "Logout": [
                "Request": Contracts.Logout.Request.keyDictionary,
                "Response": Contracts.Logout.Response.keyDictionary,
            ],
            "PasswordChange": [
                "Request": Contracts.PasswordChange.Request.keyDictionary,
                "Response": Contracts.PasswordChange.Response.keyDictionary,
            ],
            "Signup": [
                "Request": Contracts.Signup.Request.keyDictionary,
                "Response": Contracts.Signup.Response.keyDictionary,
            ],
            "UpdateUserAccessLevel": [
                "Request": Contracts.UpdateUserAccessLevel.Request.keyDictionary,
                "Response": Contracts.UpdateUserAccessLevel.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Author.Contracts {
    typealias FieldMapping = Services.Shared.FieldMapping
    typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    typealias CharacterInfo = Services.Shared.CharacterInfo
    typealias EventRequest = Services.Shared.EventRequest
    typealias UserSignupRequest = Services.Shared.UserSignupRequest
    typealias NodeInfo = Services.Shared.NodeInfo
    typealias PingRequest = Services.Shared.PingRequest
    typealias PingResponse = Services.Shared.PingResponse
    typealias CheckinRequest = Services.Shared.CheckinRequest
    typealias CheckinResponse = Services.Shared.CheckinResponse
    typealias LoginRequest = Services.Shared.LoginRequest
    typealias LoginResponse = Services.Shared.LoginResponse
    typealias CommentUserInfo = Services.Shared.CommentUserInfo
    typealias Comment = Services.Shared.Comment
    typealias User = Services.Shared.User

    enum Checkin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.CheckinRequest
        public typealias Response = Services.Shared.CheckinResponse

        public static let URI = "Checkin"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum Ping: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.PingRequest
        public typealias Response = Services.Shared.PingResponse

        public static let URI = "Ping"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum RaiseEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RaiseEvent"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum AnnounceEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "AnnounceEvent"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum Login: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "Login"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum InternalLogin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest

        public static let URI = "InternalLogin"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let session: String
            public let IDUser: String

            public init(session: String, IDUser: String) {
                self.session = session
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "IDUser",
                    ]
                )

                let value_session: String? = try? (self.extract(param: "session", from: dictionary) as String)
                let value_IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "session": {
                        guard let _ = value_session else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "IDUser": {
                        guard let _ = value_IDUser else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    session: value_session!,
                    IDUser: value_IDUser!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Response.extract(param: "session", from: dictionary),
                    IDUser: try Response.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }

        }
    }

    enum UserInfo: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "UserInfo"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let ID: String

            public init(ID: String) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "ID",
                    ]
                )

                let value_ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "ID": {
                        guard let _ = value_ID else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_ID!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    ID: value_ID!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let ID: String
            public let username: String
            public let sex: String
            public let isBanned: Bool
            public let accessLevel: String

            public init(ID: String, username: String, sex: String, isBanned: Bool, accessLevel: String) {
                self.ID = ID
                self.username = username
                self.sex = sex
                self.isBanned = isBanned
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "ID",
                        "username",
                        "sex",
                        "isBanned",
                        "accessLevel",
                    ]
                )

                let value_ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)
                let value_username: String? = try? (self.extract(param: "username", from: dictionary) as String)
                let value_sex: String? = try? (self.extract(param: "sex", from: dictionary) as String)
                let value_isBanned: Bool? = try? (self.extract(param: "isBanned", from: dictionary) as Bool)
                let value_accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "ID": {
                        guard let _ = value_ID else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_ID!)
                    },
                    "username": {
                        guard let _ = value_username else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "sex": {
                        guard let _ = value_sex else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(value_sex!)
                    },
                    "isBanned": {
                        guard let _ = value_isBanned else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "accessLevel": {
                        guard let _ = value_accessLevel else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.In(allowedValues: ["User", "Admin"]).validate(value_accessLevel!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    ID: value_ID!,
                    username: value_username!,
                    sex: value_sex!,
                    isBanned: value_isBanned!,
                    accessLevel: value_accessLevel!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Response.extract(param: "ID", from: dictionary),
                    username: try Response.extract(param: "username", from: dictionary),
                    sex: try Response.extract(param: "sex", from: dictionary),
                    isBanned: try Response.extract(param: "isBanned", from: dictionary),
                    accessLevel: try Response.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("isBanned"): try self.encode(self.isBanned),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }

        }
    }

    enum UserInfoInternal: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.User

        public static let URI = "UserInfoInternal"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let ID: String

            public init(ID: String) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "ID",
                    ]
                )

                let value_ID: String? = try? (self.extract(param: "ID", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "ID": {
                        guard let _ = value_ID else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_ID!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    ID: value_ID!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }

        }
    }

    enum Authenticate: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "Authenticate"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let portal: LGNC.Entity.Cookie
            public let session: LGNC.Entity.Cookie

            public init(portal: LGNC.Entity.Cookie, session: LGNC.Entity.Cookie) {
                self.portal = portal
                self.session = session
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "portal",
                        "session",
                    ]
                )

                let value_portal: LGNC.Entity.Cookie? = try await self.extractCookie(param: "portal", from: dictionary)
                let value_session: LGNC.Entity.Cookie? = try await self.extractCookie(param: "session", from: dictionary)

                let validatorClosures: [String: ValidationClosure] = [
                    "portal": {
                        guard let _ = value_portal else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "session": {
                        guard let _ = value_session else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    portal: value_portal!,
                    session: value_session!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    portal: try Request.extract(param: "portal", from: dictionary),
                    session: try Request.extract(param: "session", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("session"): try self.encode(self.session),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let IDUser: String?

            public init(IDUser: String? = nil) {
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "IDUser",
                    ]
                )

                let value_IDUser: String?? = try? (self.extract(param: "IDUser", from: dictionary, isOptional: true) as String?)

                let validatorClosures: [String: ValidationClosure] = [
                    "IDUser": {
                        guard let value = value_IDUser else {
                            throw Validation.Error.MissingValue()
                        }
                        if value == nil {
                            throw Validation.Error.SkipMissingOptionalValueValidators()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    IDUser: value_IDUser!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDUser: try Response.extract(param: "IDUser", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }

        }
    }

    enum ValidateEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "ValidateEmail"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let node: String
            public let validationToken: String
            public let IDUser: String

            public init(node: String, validationToken: String, IDUser: String) {
                self.node = node
                self.validationToken = validationToken
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "node",
                        "validationToken",
                        "IDUser",
                    ]
                )

                let value_node: String? = try? (self.extract(param: "node", from: dictionary) as String)
                let value_validationToken: String? = try? (self.extract(param: "validationToken", from: dictionary) as String)
                let value_IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "node": {
                        guard let _ = value_node else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "validationToken": {
                        guard let _ = value_validationToken else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "IDUser": {
                        guard let _ = value_IDUser else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_IDUser!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    node: value_node!,
                    validationToken: value_validationToken!,
                    IDUser: value_IDUser!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    node: try Request.extract(param: "node", from: dictionary),
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("node"): try self.encode(self.node),
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }

        }
    }

    enum ResendValidationEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ResendValidationEmail"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let email: String
            public let recaptchaToken: String

            public init(email: String, recaptchaToken: String) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "email",
                        "recaptchaToken",
                    ]
                )

                let value_email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let value_recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "email": {
                        guard let _ = value_email else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "recaptchaToken": {
                        guard let _ = value_recaptchaToken else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    email: value_email!,
                    recaptchaToken: value_recaptchaToken!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }

        }
    }

    enum PasswordResetStep1: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "PasswordResetStep1"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let email: String
            public let recaptchaToken: String

            public init(email: String, recaptchaToken: String) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "email",
                        "recaptchaToken",
                    ]
                )

                let value_email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let value_recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "email": {
                        guard let _ = value_email else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "recaptchaToken": {
                        guard let _ = value_recaptchaToken else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    email: value_email!,
                    recaptchaToken: value_recaptchaToken!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }

        }
    }

    enum PasswordResetStep2: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "PasswordResetStep2"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let validationToken: String
            public let IDUser: String
            public let password1: String
            public let password2: String

            public init(validationToken: String, IDUser: String, password1: String, password2: String) {
                self.validationToken = validationToken
                self.IDUser = IDUser
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "validationToken",
                        "IDUser",
                        "password1",
                        "password2",
                    ]
                )

                let value_validationToken: String? = try? (self.extract(param: "validationToken", from: dictionary) as String)
                let value_IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)
                let value_password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let value_password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "validationToken": {
                        guard let _ = value_validationToken else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "IDUser": {
                        guard let _ = value_IDUser else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_IDUser!)
                    },
                    "password1": {
                        guard let _ = value_password1 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Length.Min(length: 6, message: "Password must be at least 6 characters long").validate(value_password1!)
                    try await Validation.Length.Max(length: 64, message: "Password must be less than 64 characters long").validate(value_password1!)
                    },
                    "password2": {
                        guard let _ = value_password2 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Identical(right: value_password1!, message: "Passwords must match").validate(value_password2!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    validationToken: value_validationToken!,
                    IDUser: value_IDUser!,
                    password1: value_password1!,
                    password2: value_password2!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }

        }
    }

    enum InternalSignup: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "InternalSignup"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            private static var validatorUsernameClosure: Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback? = nil
            private static var validatorEmailClosure: Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback? = nil

            public enum CallbackValidatorUsernameAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenUsernameAlreadyExists = "User with given username already exists"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .UserWithGivenUsernameAlreadyExists: return (code: 10001, message: self.rawValue)
                    }
                }
            }

            public enum CallbackValidatorEmailAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenEmailAlreadyExists = "User with given email already exists"

                public func getErrorTuple() -> ErrorTuple {
                    switch self {
                        case .UserWithGivenEmailAlreadyExists: return (code: 10001, message: self.rawValue)
                    }
                }
            }

            public let username: String
            public let email: String
            public let password1: String
            public let password2: String
            public let sex: String
            public let language: String
            public let recaptchaToken: String
            public let ip: String
            public let userAgent: String
            public let country: String

            public init(
                username: String,
                email: String,
                password1: String,
                password2: String,
                sex: String,
                language: String,
                recaptchaToken: String,
                ip: String,
                userAgent: String,
                country: String
            ) {
                self.username = username
                self.email = email
                self.password1 = password1
                self.password2 = password2
                self.sex = sex
                self.language = language
                self.recaptchaToken = recaptchaToken
                self.ip = ip
                self.userAgent = userAgent
                self.country = country
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "username",
                        "email",
                        "password1",
                        "password2",
                        "sex",
                        "language",
                        "recaptchaToken",
                        "ip",
                        "userAgent",
                        "country",
                    ]
                )

                let value_username: String? = try? (self.extract(param: "username", from: dictionary) as String)
                let value_email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let value_password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let value_password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)
                let value_sex: String? = try? (self.extract(param: "sex", from: dictionary) as String)
                let value_language: String? = try? (self.extract(param: "language", from: dictionary) as String)
                let value_recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)
                let value_ip: String? = try? (self.extract(param: "ip", from: dictionary) as String)
                let value_userAgent: String? = try? (self.extract(param: "userAgent", from: dictionary) as String)
                let value_country: String? = try? (self.extract(param: "country", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "username": {
                        guard let _ = value_username else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.cumulative([
                            {
                                try await Validation.Regexp(pattern: "^[\\p{L}\\d_\\- ]+$", message: "Username must only consist of letters, numbers and underscores").validate(value_username!)
                            },
                            {
                                try await Validation.Length.Min(length: 3).validate(value_username!)
                            },
                            {
                                try await Validation.Length.Max(length: 24).validate(value_username!)
                            },
                        ])
                        if let validator = self.validatorUsernameClosure {
                            try await Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>(callback: validator).validate(value_username!)
                        }
                    },
                    "email": {
                        guard let _ = value_email else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Regexp(pattern: "^.+@.+\\..+$", message: "Invalid email format").validate(value_email!)
                        if let validator = self.validatorEmailClosure {
                            try await Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>(callback: validator).validate(value_email!)
                        }
                    },
                    "password1": {
                        guard let _ = value_password1 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Length.Min(length: 6, message: "Password must be at least 6 characters long").validate(value_password1!)
                    try await Validation.Length.Max(length: 64, message: "Password must be less than 64 characters long").validate(value_password1!)
                    },
                    "password2": {
                        guard let _ = value_password2 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Identical(right: value_password1!, message: "Passwords must match").validate(value_password2!)
                    },
                    "sex": {
                        guard let _ = value_sex else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(value_sex!)
                    },
                    "language": {
                        guard let _ = value_language else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.In(allowedValues: ["en", "ru"]).validate(value_language!)
                    },
                    "recaptchaToken": {
                        guard let _ = value_recaptchaToken else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "ip": {
                        guard let _ = value_ip else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "userAgent": {
                        guard let _ = value_userAgent else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "country": {
                        guard let _ = value_country else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    username: value_username!,
                    email: value_email!,
                    password1: value_password1!,
                    password2: value_password2!,
                    sex: value_sex!,
                    language: value_language!,
                    recaptchaToken: value_recaptchaToken!,
                    ip: value_ip!,
                    userAgent: value_userAgent!,
                    country: value_country!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    username: try Request.extract(param: "username", from: dictionary),
                    email: try Request.extract(param: "email", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary),
                    sex: try Request.extract(param: "sex", from: dictionary),
                    language: try Request.extract(param: "language", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary),
                    ip: try Request.extract(param: "ip", from: dictionary),
                    userAgent: try Request.extract(param: "userAgent", from: dictionary),
                    country: try Request.extract(param: "country", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("language"): try self.encode(self.language),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                    self.getDictionaryKey("ip"): try self.encode(self.ip),
                    self.getDictionaryKey("userAgent"): try self.encode(self.userAgent),
                    self.getDictionaryKey("country"): try self.encode(self.country),
                ]
            }

            public static func validateUsername(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback
            ) {
                self.validatorUsernameClosure = callback
            }

            public static func validateEmail(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback
            ) {
                self.validatorEmailClosure = callback
            }

        }
    }

    enum Logout: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Logout"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie

            public init(session: LGNC.Entity.Cookie, portal: LGNC.Entity.Cookie) {
                self.session = session
                self.portal = portal
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                    ]
                )

                let value_session: LGNC.Entity.Cookie? = try await self.extractCookie(param: "session", from: dictionary)
                let value_portal: LGNC.Entity.Cookie? = try await self.extractCookie(param: "portal", from: dictionary)

                let validatorClosures: [String: ValidationClosure] = [
                    "session": {
                        guard let _ = value_session else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "portal": {
                        guard let _ = value_portal else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    session: value_session!,
                    portal: value_portal!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                ]
            }

        }
    }

    enum PasswordChange: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "PasswordChange"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let currentPassword: String
            public let password1: String
            public let password2: String

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                currentPassword: String,
                password1: String,
                password2: String
            ) {
                self.session = session
                self.portal = portal
                self.currentPassword = currentPassword
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "currentPassword",
                        "password1",
                        "password2",
                    ]
                )

                let value_session: LGNC.Entity.Cookie? = try await self.extractCookie(param: "session", from: dictionary)
                let value_portal: LGNC.Entity.Cookie? = try await self.extractCookie(param: "portal", from: dictionary)
                let value_currentPassword: String? = try? (self.extract(param: "currentPassword", from: dictionary) as String)
                let value_password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let value_password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "session": {
                        guard let _ = value_session else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "portal": {
                        guard let _ = value_portal else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "currentPassword": {
                        guard let _ = value_currentPassword else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "password1": {
                        guard let _ = value_password1 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Length.Min(length: 6, message: "Password must be at least 6 characters long").validate(value_password1!)
                    try await Validation.Length.Max(length: 64, message: "Password must be less than 64 characters long").validate(value_password1!)
                    },
                    "password2": {
                        guard let _ = value_password2 else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.Identical(right: value_password1!, message: "Passwords must match").validate(value_password2!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    session: value_session!,
                    portal: value_portal!,
                    currentPassword: value_currentPassword!,
                    password1: value_password1!,
                    password2: value_password2!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    currentPassword: try Request.extract(param: "currentPassword", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("currentPassword"): try self.encode(self.currentPassword),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }

        }
    }

    enum Signup: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.UserSignupRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Signup"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

    }

    enum UpdateUserAccessLevel: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "UpdateUserAccessLevel"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeBody: Optional<CanonicalGuaranteeBody> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let session: LGNC.Entity.Cookie
            public let portal: LGNC.Entity.Cookie
            public let IDUser: String
            public let accessLevel: String

            public init(
                session: LGNC.Entity.Cookie,
                portal: LGNC.Entity.Cookie,
                IDUser: String,
                accessLevel: String
            ) {
                self.session = session
                self.portal = portal
                self.IDUser = IDUser
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(from dictionary: Entita.Dict) async throws -> Self {
                try self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "session",
                        "portal",
                        "IDUser",
                        "accessLevel",
                    ]
                )

                let value_session: LGNC.Entity.Cookie? = try await self.extractCookie(param: "session", from: dictionary)
                let value_portal: LGNC.Entity.Cookie? = try await self.extractCookie(param: "portal", from: dictionary)
                let value_IDUser: String? = try? (self.extract(param: "IDUser", from: dictionary) as String)
                let value_accessLevel: String? = try? (self.extract(param: "accessLevel", from: dictionary) as String)

                let validatorClosures: [String: ValidationClosure] = [
                    "session": {
                        guard let _ = value_session else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "portal": {
                        guard let _ = value_portal else {
                            throw Validation.Error.MissingValue()
                        }

                    },
                    "IDUser": {
                        guard let _ = value_IDUser else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.UUID().validate(value_IDUser!)
                    },
                    "accessLevel": {
                        guard let _ = value_accessLevel else {
                            throw Validation.Error.MissingValue()
                        }
                        try await Validation.In(allowedValues: ["User", "Admin"]).validate(value_accessLevel!)
                    },
                ]

                let validationErrors = await self.reduce(closures: validatorClosures)
                guard validationErrors.isEmpty else {
                    throw LGNC.E.DecodeError(validationErrors)
                }

                return self.init(
                    session: value_session!,
                    portal: value_portal!,
                    IDUser: value_IDUser!,
                    accessLevel: value_accessLevel!
                )
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    session: try Request.extract(param: "session", from: dictionary),
                    portal: try Request.extract(param: "portal", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    accessLevel: try Request.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("session"): try self.encode(self.session),
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }

        }
    }
}