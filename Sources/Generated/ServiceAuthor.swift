/**
 * This file has been autogenerated by LGNC assembler on 2019-06-12 21:20:51.819259.
 * All changes will be lost on next assembly.
 */

import Entita
import Foundation
import LGNC
import LGNCore
import LGNP
import LGNS
import NIO

public extension Services {
    struct Author: Service {
        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 1711,
            .HTTP: 8080,
        ]

        public struct Contracts {}

        public static let info: [String: String] = [
            "ElderName": "hudruk",
        ]

        public static let contractMap: Contract.Map = [
            Contracts.Checkin.URI: (transports: Contracts.Checkin.transports, executor: Author.contractCheckin),
            Contracts.Ping.URI: (transports: Contracts.Ping.transports, executor: Author.contractPing),
            Contracts.RaiseEvent.URI: (transports: Contracts.RaiseEvent.transports, executor: Author.contractRaiseEvent),
            Contracts.AnnounceEvent.URI: (transports: Contracts.AnnounceEvent.transports, executor: Author.contractAnnounceEvent),
            Contracts.Login.URI: (transports: Contracts.Login.transports, executor: Author.contractLogin),
            Contracts.InternalLogin.URI: (transports: Contracts.InternalLogin.transports, executor: Author.contractInternalLogin),
            Contracts.UserInfo.URI: (transports: Contracts.UserInfo.transports, executor: Author.contractUserInfo),
            Contracts.UserInfoInternal.URI: (transports: Contracts.UserInfoInternal.transports, executor: Author.contractUserInfoInternal),
            Contracts.Authenticate.URI: (transports: Contracts.Authenticate.transports, executor: Author.contractAuthenticate),
            Contracts.ChangePassword.URI: (transports: Contracts.ChangePassword.transports, executor: Author.contractChangePassword),
            Contracts.ValidateEmail.URI: (transports: Contracts.ValidateEmail.transports, executor: Author.contractValidateEmail),
            Contracts.ResendValidationEmail.URI: (transports: Contracts.ResendValidationEmail.transports, executor: Author.contractResendValidationEmail),
            Contracts.ResetPasswordStep1.URI: (transports: Contracts.ResetPasswordStep1.transports, executor: Author.contractResetPasswordStep1),
            Contracts.ResetPasswordStep2.URI: (transports: Contracts.ResetPasswordStep2.transports, executor: Author.contractResetPasswordStep2),
            Contracts.InternalSignup.URI: (transports: Contracts.InternalSignup.transports, executor: Author.contractInternalSignup),
            Contracts.Signup.URI: (transports: Contracts.Signup.transports, executor: Author.contractSignup),
        ]

        private static var contractCheckinCallback: Contracts.Checkin.NormalizedCallback!
        private static var contractPingCallback: Contracts.Ping.NormalizedCallback!
        private static var contractRaiseEventCallback: Contracts.RaiseEvent.NormalizedCallback!
        private static var contractAnnounceEventCallback: Contracts.AnnounceEvent.NormalizedCallback!
        private static var contractLoginCallback: Contracts.Login.NormalizedCallback!
        private static var contractInternalLoginCallback: Contracts.InternalLogin.NormalizedCallback!
        private static var contractUserInfoCallback: Contracts.UserInfo.NormalizedCallback!
        private static var contractUserInfoInternalCallback: Contracts.UserInfoInternal.NormalizedCallback!
        private static var contractAuthenticateCallback: Contracts.Authenticate.NormalizedCallback!
        private static var contractChangePasswordCallback: Contracts.ChangePassword.NormalizedCallback!
        private static var contractValidateEmailCallback: Contracts.ValidateEmail.NormalizedCallback!
        private static var contractResendValidationEmailCallback: Contracts.ResendValidationEmail.NormalizedCallback!
        private static var contractResetPasswordStep1Callback: Contracts.ResetPasswordStep1.NormalizedCallback!
        private static var contractResetPasswordStep2Callback: Contracts.ResetPasswordStep2.NormalizedCallback!
        private static var contractInternalSignupCallback: Contracts.InternalSignup.NormalizedCallback!
        private static var contractSignupCallback: Contracts.Signup.NormalizedCallback!

        public static func guaranteeCheckinContract(_ callback: @escaping Contracts.Checkin.Callback) {
            self.contractCheckinCallback = Contracts.Checkin.normalize(callback: callback)
        }

        public static func guaranteeCheckinContract(_ callback: @escaping Contracts.Checkin.NonFutureCallback) {
            self.guaranteeCheckinContract(Contracts.Checkin.futurize(callback: callback))
        }

        public static func guaranteePingContract(_ callback: @escaping Contracts.Ping.Callback) {
            self.contractPingCallback = Contracts.Ping.normalize(callback: callback)
        }

        public static func guaranteePingContract(_ callback: @escaping Contracts.Ping.NonFutureCallback) {
            self.guaranteePingContract(Contracts.Ping.futurize(callback: callback))
        }

        public static func guaranteeRaiseEventContract(_ callback: @escaping Contracts.RaiseEvent.Callback) {
            self.contractRaiseEventCallback = Contracts.RaiseEvent.normalize(callback: callback)
        }

        public static func guaranteeRaiseEventContract(_ callback: @escaping Contracts.RaiseEvent.NonFutureCallback) {
            self.guaranteeRaiseEventContract(Contracts.RaiseEvent.futurize(callback: callback))
        }

        public static func guaranteeAnnounceEventContract(_ callback: @escaping Contracts.AnnounceEvent.Callback) {
            self.contractAnnounceEventCallback = Contracts.AnnounceEvent.normalize(callback: callback)
        }

        public static func guaranteeAnnounceEventContract(_ callback: @escaping Contracts.AnnounceEvent.NonFutureCallback) {
            self.guaranteeAnnounceEventContract(Contracts.AnnounceEvent.futurize(callback: callback))
        }

        public static func guaranteeLoginContract(_ callback: @escaping Contracts.Login.Callback) {
            self.contractLoginCallback = Contracts.Login.normalize(callback: callback)
        }

        public static func guaranteeLoginContract(_ callback: @escaping Contracts.Login.NonFutureCallback) {
            self.guaranteeLoginContract(Contracts.Login.futurize(callback: callback))
        }

        public static func guaranteeInternalLoginContract(_ callback: @escaping Contracts.InternalLogin.Callback) {
            self.contractInternalLoginCallback = Contracts.InternalLogin.normalize(callback: callback)
        }

        public static func guaranteeInternalLoginContract(_ callback: @escaping Contracts.InternalLogin.NonFutureCallback) {
            self.guaranteeInternalLoginContract(Contracts.InternalLogin.futurize(callback: callback))
        }

        public static func guaranteeUserInfoContract(_ callback: @escaping Contracts.UserInfo.Callback) {
            self.contractUserInfoCallback = Contracts.UserInfo.normalize(callback: callback)
        }

        public static func guaranteeUserInfoContract(_ callback: @escaping Contracts.UserInfo.NonFutureCallback) {
            self.guaranteeUserInfoContract(Contracts.UserInfo.futurize(callback: callback))
        }

        public static func guaranteeUserInfoInternalContract(_ callback: @escaping Contracts.UserInfoInternal.Callback) {
            self.contractUserInfoInternalCallback = Contracts.UserInfoInternal.normalize(callback: callback)
        }

        public static func guaranteeUserInfoInternalContract(_ callback: @escaping Contracts.UserInfoInternal.NonFutureCallback) {
            self.guaranteeUserInfoInternalContract(Contracts.UserInfoInternal.futurize(callback: callback))
        }

        public static func guaranteeAuthenticateContract(_ callback: @escaping Contracts.Authenticate.Callback) {
            self.contractAuthenticateCallback = Contracts.Authenticate.normalize(callback: callback)
        }

        public static func guaranteeAuthenticateContract(_ callback: @escaping Contracts.Authenticate.NonFutureCallback) {
            self.guaranteeAuthenticateContract(Contracts.Authenticate.futurize(callback: callback))
        }

        public static func guaranteeChangePasswordContract(_ callback: @escaping Contracts.ChangePassword.Callback) {
            self.contractChangePasswordCallback = Contracts.ChangePassword.normalize(callback: callback)
        }

        public static func guaranteeChangePasswordContract(_ callback: @escaping Contracts.ChangePassword.NonFutureCallback) {
            self.guaranteeChangePasswordContract(Contracts.ChangePassword.futurize(callback: callback))
        }

        public static func guaranteeValidateEmailContract(_ callback: @escaping Contracts.ValidateEmail.Callback) {
            self.contractValidateEmailCallback = Contracts.ValidateEmail.normalize(callback: callback)
        }

        public static func guaranteeValidateEmailContract(_ callback: @escaping Contracts.ValidateEmail.NonFutureCallback) {
            self.guaranteeValidateEmailContract(Contracts.ValidateEmail.futurize(callback: callback))
        }

        public static func guaranteeResendValidationEmailContract(_ callback: @escaping Contracts.ResendValidationEmail.Callback) {
            self.contractResendValidationEmailCallback = Contracts.ResendValidationEmail.normalize(callback: callback)
        }

        public static func guaranteeResendValidationEmailContract(_ callback: @escaping Contracts.ResendValidationEmail.NonFutureCallback) {
            self.guaranteeResendValidationEmailContract(Contracts.ResendValidationEmail.futurize(callback: callback))
        }

        public static func guaranteeResetPasswordStep1Contract(_ callback: @escaping Contracts.ResetPasswordStep1.Callback) {
            self.contractResetPasswordStep1Callback = Contracts.ResetPasswordStep1.normalize(callback: callback)
        }

        public static func guaranteeResetPasswordStep1Contract(_ callback: @escaping Contracts.ResetPasswordStep1.NonFutureCallback) {
            self.guaranteeResetPasswordStep1Contract(Contracts.ResetPasswordStep1.futurize(callback: callback))
        }

        public static func guaranteeResetPasswordStep2Contract(_ callback: @escaping Contracts.ResetPasswordStep2.Callback) {
            self.contractResetPasswordStep2Callback = Contracts.ResetPasswordStep2.normalize(callback: callback)
        }

        public static func guaranteeResetPasswordStep2Contract(_ callback: @escaping Contracts.ResetPasswordStep2.NonFutureCallback) {
            self.guaranteeResetPasswordStep2Contract(Contracts.ResetPasswordStep2.futurize(callback: callback))
        }

        public static func guaranteeInternalSignupContract(_ callback: @escaping Contracts.InternalSignup.Callback) {
            self.contractInternalSignupCallback = Contracts.InternalSignup.normalize(callback: callback)
        }

        public static func guaranteeInternalSignupContract(_ callback: @escaping Contracts.InternalSignup.NonFutureCallback) {
            self.guaranteeInternalSignupContract(Contracts.InternalSignup.futurize(callback: callback))
        }

        public static func guaranteeSignupContract(_ callback: @escaping Contracts.Signup.Callback) {
            self.contractSignupCallback = Contracts.Signup.normalize(callback: callback)
        }

        public static func guaranteeSignupContract(_ callback: @escaping Contracts.Signup.NonFutureCallback) {
            self.guaranteeSignupContract(Contracts.Signup.futurize(callback: callback))
        }

        public static func executeCheckinContract(
            at address: Address,
            with request: Contracts.Checkin.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Checkin.Response> {
            return Contracts.Checkin.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executePingContract(
            at address: Address,
            with request: Contracts.Ping.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Ping.Response> {
            return Contracts.Ping.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeRaiseEventContract(
            at address: Address,
            with request: Contracts.RaiseEvent.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.RaiseEvent.Response> {
            return Contracts.RaiseEvent.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeAnnounceEventContract(
            at address: Address,
            with request: Contracts.AnnounceEvent.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.AnnounceEvent.Response> {
            return Contracts.AnnounceEvent.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeLoginContract(
            at address: Address,
            with request: Contracts.Login.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Login.Response> {
            return Contracts.Login.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeInternalLoginContract(
            at address: Address,
            with request: Contracts.InternalLogin.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.InternalLogin.Response> {
            return Contracts.InternalLogin.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUserInfoContract(
            at address: Address,
            with request: Contracts.UserInfo.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.UserInfo.Response> {
            return Contracts.UserInfo.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeUserInfoInternalContract(
            at address: Address,
            with request: Contracts.UserInfoInternal.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.UserInfoInternal.Response> {
            return Contracts.UserInfoInternal.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeAuthenticateContract(
            at address: Address,
            with request: Contracts.Authenticate.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Authenticate.Response> {
            return Contracts.Authenticate.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeChangePasswordContract(
            at address: Address,
            with request: Contracts.ChangePassword.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ChangePassword.Response> {
            return Contracts.ChangePassword.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeValidateEmailContract(
            at address: Address,
            with request: Contracts.ValidateEmail.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ValidateEmail.Response> {
            return Contracts.ValidateEmail.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeResendValidationEmailContract(
            at address: Address,
            with request: Contracts.ResendValidationEmail.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ResendValidationEmail.Response> {
            return Contracts.ResendValidationEmail.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeResetPasswordStep1Contract(
            at address: Address,
            with request: Contracts.ResetPasswordStep1.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ResetPasswordStep1.Response> {
            return Contracts.ResetPasswordStep1.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeResetPasswordStep2Contract(
            at address: Address,
            with request: Contracts.ResetPasswordStep2.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.ResetPasswordStep2.Response> {
            return Contracts.ResetPasswordStep2.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeInternalSignupContract(
            at address: Address,
            with request: Contracts.InternalSignup.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.InternalSignup.Response> {
            return Contracts.InternalSignup.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        public static func executeSignupContract(
            at address: Address,
            with request: Contracts.Signup.Request,
            using client: LGNS.Client,
            controlBitmask: LGNP.Message.ControlBitmask = .defaultValues,
            uuid: UUID = UUID()
        ) -> Future<Contracts.Signup.Response> {
            return Contracts.Signup.execute(at: address, with: request, using: client, controlBitmask: controlBitmask, uuid: uuid)
        }

        private static func contractCheckin(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Checkin._invoke(with: self.contractCheckinCallback, request: parsedDict, requestInfo: requestInfo, name: "Checkin")
        }

        private static func contractPing(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Ping._invoke(with: self.contractPingCallback, request: parsedDict, requestInfo: requestInfo, name: "Ping")
        }

        private static func contractRaiseEvent(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.RaiseEvent._invoke(with: self.contractRaiseEventCallback, request: parsedDict, requestInfo: requestInfo, name: "RaiseEvent")
        }

        private static func contractAnnounceEvent(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.AnnounceEvent._invoke(with: self.contractAnnounceEventCallback, request: parsedDict, requestInfo: requestInfo, name: "AnnounceEvent")
        }

        private static func contractLogin(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Login._invoke(with: self.contractLoginCallback, request: parsedDict, requestInfo: requestInfo, name: "Login")
        }

        private static func contractInternalLogin(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.InternalLogin._invoke(with: self.contractInternalLoginCallback, request: parsedDict, requestInfo: requestInfo, name: "InternalLogin")
        }

        private static func contractUserInfo(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.UserInfo._invoke(with: self.contractUserInfoCallback, request: parsedDict, requestInfo: requestInfo, name: "UserInfo")
        }

        private static func contractUserInfoInternal(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.UserInfoInternal._invoke(with: self.contractUserInfoInternalCallback, request: parsedDict, requestInfo: requestInfo, name: "UserInfoInternal")
        }

        private static func contractAuthenticate(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Authenticate._invoke(with: self.contractAuthenticateCallback, request: parsedDict, requestInfo: requestInfo, name: "Authenticate")
        }

        private static func contractChangePassword(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ChangePassword._invoke(with: self.contractChangePasswordCallback, request: parsedDict, requestInfo: requestInfo, name: "ChangePassword")
        }

        private static func contractValidateEmail(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ValidateEmail._invoke(with: self.contractValidateEmailCallback, request: parsedDict, requestInfo: requestInfo, name: "ValidateEmail")
        }

        private static func contractResendValidationEmail(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ResendValidationEmail._invoke(with: self.contractResendValidationEmailCallback, request: parsedDict, requestInfo: requestInfo, name: "ResendValidationEmail")
        }

        private static func contractResetPasswordStep1(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ResetPasswordStep1._invoke(with: self.contractResetPasswordStep1Callback, request: parsedDict, requestInfo: requestInfo, name: "ResetPasswordStep1")
        }

        private static func contractResetPasswordStep2(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.ResetPasswordStep2._invoke(with: self.contractResetPasswordStep2Callback, request: parsedDict, requestInfo: requestInfo, name: "ResetPasswordStep2")
        }

        private static func contractInternalSignup(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.InternalSignup._invoke(with: self.contractInternalSignupCallback, request: parsedDict, requestInfo: requestInfo, name: "InternalSignup")
        }

        private static func contractSignup(requestInfo: LGNCore.RequestInfo, parsedDict: Entita.Dict) -> Future<Entity> {
            return Contracts.Signup._invoke(with: self.contractSignupCallback, request: parsedDict, requestInfo: requestInfo, name: "Signup")
        }

        public static func validateContractCheckinFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Checkin.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Checkin.Request.validateName(callback)
        }

        public static func validateContractPingFieldName(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Ping.Request.CallbackValidatorNameAllowedValues>.Callback
        ) {
            Contracts.Ping.Request.validateName(callback)
        }

        public static func validateContractInternalSignupFieldUsername(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.InternalSignup.Request.CallbackValidatorUsernameAllowedValues>.Callback
        ) {
            Contracts.InternalSignup.Request.validateUsername(callback)
        }

        public static func validateContractInternalSignupFieldEmail(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.InternalSignup.Request.CallbackValidatorEmailAllowedValues>.Callback
        ) {
            Contracts.InternalSignup.Request.validateEmail(callback)
        }

        public static func validateContractSignupFieldUsername(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Signup.Request.CallbackValidatorUsernameAllowedValues>.Callback
        ) {
            Contracts.Signup.Request.validateUsername(callback)
        }

        public static func validateContractSignupFieldEmail(
            _ callback: @escaping Validation.CallbackWithAllowedValues<Contracts.Signup.Request.CallbackValidatorEmailAllowedValues>.Callback
        ) {
            Contracts.Signup.Request.validateEmail(callback)
        }

        public static func checkContractsCallbacks() -> Bool {
            var result = true

            if self.contractCheckinCallback == nil {
                Logger(label: "LGNC.Contracts.Checkin").error("Contract 'Checkin' is not guaranteed")
                result = false
            }

            if self.contractPingCallback == nil {
                Logger(label: "LGNC.Contracts.Ping").error("Contract 'Ping' is not guaranteed")
                result = false
            }

            if self.contractRaiseEventCallback == nil {
                Logger(label: "LGNC.Contracts.RaiseEvent").error("Contract 'RaiseEvent' is not guaranteed")
                result = false
            }

            if self.contractAnnounceEventCallback == nil {
                Logger(label: "LGNC.Contracts.AnnounceEvent").error("Contract 'AnnounceEvent' is not guaranteed")
                result = false
            }

            if self.contractLoginCallback == nil {
                Logger(label: "LGNC.Contracts.Login").error("Contract 'Login' is not guaranteed")
                result = false
            }

            if self.contractInternalLoginCallback == nil {
                Logger(label: "LGNC.Contracts.InternalLogin").error("Contract 'InternalLogin' is not guaranteed")
                result = false
            }

            if self.contractUserInfoCallback == nil {
                Logger(label: "LGNC.Contracts.UserInfo").error("Contract 'UserInfo' is not guaranteed")
                result = false
            }

            if self.contractUserInfoInternalCallback == nil {
                Logger(label: "LGNC.Contracts.UserInfoInternal").error("Contract 'UserInfoInternal' is not guaranteed")
                result = false
            }

            if self.contractAuthenticateCallback == nil {
                Logger(label: "LGNC.Contracts.Authenticate").error("Contract 'Authenticate' is not guaranteed")
                result = false
            }

            if self.contractChangePasswordCallback == nil {
                Logger(label: "LGNC.Contracts.ChangePassword").error("Contract 'ChangePassword' is not guaranteed")
                result = false
            }

            if self.contractValidateEmailCallback == nil {
                Logger(label: "LGNC.Contracts.ValidateEmail").error("Contract 'ValidateEmail' is not guaranteed")
                result = false
            }

            if self.contractResendValidationEmailCallback == nil {
                Logger(label: "LGNC.Contracts.ResendValidationEmail").error("Contract 'ResendValidationEmail' is not guaranteed")
                result = false
            }

            if self.contractResetPasswordStep1Callback == nil {
                Logger(label: "LGNC.Contracts.ResetPasswordStep1").error("Contract 'ResetPasswordStep1' is not guaranteed")
                result = false
            }

            if self.contractResetPasswordStep2Callback == nil {
                Logger(label: "LGNC.Contracts.ResetPasswordStep2").error("Contract 'ResetPasswordStep2' is not guaranteed")
                result = false
            }

            if self.contractInternalSignupCallback == nil {
                Logger(label: "LGNC.Contracts.InternalSignup").error("Contract 'InternalSignup' is not guaranteed")
                result = false
            }

            if self.contractSignupCallback == nil {
                Logger(label: "LGNC.Contracts.Signup").error("Contract 'Signup' is not guaranteed")
                result = false
            }

            return result
        }

        public static let keyDictionary: [String: Entita.Dict] = [
            "Checkin": [
                "Request": Contracts.Checkin.Request.keyDictionary,
                "Response": Contracts.Checkin.Response.keyDictionary,
            ],
            "Ping": [
                "Request": Contracts.Ping.Request.keyDictionary,
                "Response": Contracts.Ping.Response.keyDictionary,
            ],
            "RaiseEvent": [
                "Request": Contracts.RaiseEvent.Request.keyDictionary,
                "Response": Contracts.RaiseEvent.Response.keyDictionary,
            ],
            "AnnounceEvent": [
                "Request": Contracts.AnnounceEvent.Request.keyDictionary,
                "Response": Contracts.AnnounceEvent.Response.keyDictionary,
            ],
            "Login": [
                "Request": Contracts.Login.Request.keyDictionary,
                "Response": Contracts.Login.Response.keyDictionary,
            ],
            "InternalLogin": [
                "Request": Contracts.InternalLogin.Request.keyDictionary,
                "Response": Contracts.InternalLogin.Response.keyDictionary,
            ],
            "UserInfo": [
                "Request": Contracts.UserInfo.Request.keyDictionary,
                "Response": Contracts.UserInfo.Response.keyDictionary,
            ],
            "UserInfoInternal": [
                "Request": Contracts.UserInfoInternal.Request.keyDictionary,
                "Response": Contracts.UserInfoInternal.Response.keyDictionary,
            ],
            "Authenticate": [
                "Request": Contracts.Authenticate.Request.keyDictionary,
                "Response": Contracts.Authenticate.Response.keyDictionary,
            ],
            "ChangePassword": [
                "Request": Contracts.ChangePassword.Request.keyDictionary,
                "Response": Contracts.ChangePassword.Response.keyDictionary,
            ],
            "ValidateEmail": [
                "Request": Contracts.ValidateEmail.Request.keyDictionary,
                "Response": Contracts.ValidateEmail.Response.keyDictionary,
            ],
            "ResendValidationEmail": [
                "Request": Contracts.ResendValidationEmail.Request.keyDictionary,
                "Response": Contracts.ResendValidationEmail.Response.keyDictionary,
            ],
            "ResetPasswordStep1": [
                "Request": Contracts.ResetPasswordStep1.Request.keyDictionary,
                "Response": Contracts.ResetPasswordStep1.Response.keyDictionary,
            ],
            "ResetPasswordStep2": [
                "Request": Contracts.ResetPasswordStep2.Request.keyDictionary,
                "Response": Contracts.ResetPasswordStep2.Response.keyDictionary,
            ],
            "InternalSignup": [
                "Request": Contracts.InternalSignup.Request.keyDictionary,
                "Response": Contracts.InternalSignup.Response.keyDictionary,
            ],
            "Signup": [
                "Request": Contracts.Signup.Request.keyDictionary,
                "Response": Contracts.Signup.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Author.Contracts {
    typealias FieldMapping = Services.Shared.FieldMapping
    typealias ServiceFieldMapping = Services.Shared.ServiceFieldMapping
    typealias ServiceFieldMappings = Services.Shared.ServiceFieldMappings
    typealias CharacterInfo = Services.Shared.CharacterInfo
    typealias EventRequest = Services.Shared.EventRequest
    typealias UserSignupRequest = Services.Shared.UserSignupRequest
    typealias NodeInfo = Services.Shared.NodeInfo
    typealias PingRequest = Services.Shared.PingRequest
    typealias PingResponse = Services.Shared.PingResponse
    typealias CheckinRequest = Services.Shared.CheckinRequest
    typealias CheckinResponse = Services.Shared.CheckinResponse
    typealias LoginRequest = Services.Shared.LoginRequest
    typealias LoginResponse = Services.Shared.LoginResponse
    typealias CommentUserInfo = Services.Shared.CommentUserInfo
    typealias Empty = Services.Shared.Empty
    typealias Comment = Services.Shared.Comment
    typealias User = Services.Shared.User

    struct Checkin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.CheckinRequest
        public typealias Response = Services.Shared.CheckinResponse

        public static let URI = "Checkin"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeCheckinContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeCheckinContract(callback)
        }
    }

    struct Ping: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.PingRequest
        public typealias Response = Services.Shared.PingResponse

        public static let URI = "Ping"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteePingContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteePingContract(callback)
        }
    }

    struct RaiseEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "RaiseEvent"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeRaiseEventContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeRaiseEventContract(callback)
        }
    }

    struct AnnounceEvent: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.EventRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "AnnounceEvent"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeAnnounceEventContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeAnnounceEventContract(callback)
        }
    }

    struct Login: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "Login"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeLoginContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeLoginContract(callback)
        }
    }

    struct InternalLogin: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.LoginRequest
        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "InternalLogin"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeInternalLoginContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeInternalLoginContract(callback)
        }
    }

    struct UserInfo: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "UserInfo"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeUserInfoContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeUserInfoContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
            ]

            public var ID: String

            public init(
                ID: String
            ) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "ID": [],
                ]

                var _ID: String = String()

                do {
                    do {
                        _ID = try Request.extract(param: "ID", from: dictionary)

                        if let error = Validation.UUID().validate(_ID, requestInfo.locale) {
                            validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            ID: _ID
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
                "username": "c",
                "sex": "d",
                "isBanned": "e",
                "accessLevel": "f",
            ]

            public var ID: String
            public var username: String
            public let sex: String
            public var isBanned: Bool
            public var accessLevel: String

            public init(
                ID: String,
                username: String,
                sex: String,
                isBanned: Bool,
                accessLevel: String
            ) {
                self.ID = ID
                self.username = username
                self.sex = sex
                self.isBanned = isBanned
                self.accessLevel = accessLevel
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "ID": [],
                    "username": [],
                    "sex": [],
                    "isBanned": [],
                    "accessLevel": [],
                ]

                var _ID: String = String()
                var _username: String = String()
                var _sex: String = String()
                var _isBanned: Bool = Bool()
                var _accessLevel: String = String()

                do {
                    do {
                        _ID = try Response.extract(param: "ID", from: dictionary)

                        if let error = Validation.UUID().validate(_ID, requestInfo.locale) {
                            validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _username = try Response.extract(param: "username", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["username"]!.append(eventLoop.makeSucceededFuture(("username", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _sex = try Response.extract(param: "sex", from: dictionary)

                        if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(_sex, requestInfo.locale) {
                            validatorFutures["sex"]!.append(eventLoop.makeSucceededFuture(("sex", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["sex"]!.append(eventLoop.makeSucceededFuture(("sex", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _isBanned = try Response.extract(param: "isBanned", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["isBanned"]!.append(eventLoop.makeSucceededFuture(("isBanned", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _accessLevel = try Response.extract(param: "accessLevel", from: dictionary)

                        if let error = Validation.In(allowedValues: ["User", "Moderator", "Admin"]).validate(_accessLevel, requestInfo.locale) {
                            validatorFutures["accessLevel"]!.append(eventLoop.makeSucceededFuture(("accessLevel", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["accessLevel"]!.append(eventLoop.makeSucceededFuture(("accessLevel", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            ID: _ID,
                            username: _username,
                            sex: _sex,
                            isBanned: _isBanned,
                            accessLevel: _accessLevel
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Response.extract(param: "ID", from: dictionary),
                    username: try Response.extract(param: "username", from: dictionary),
                    sex: try Response.extract(param: "sex", from: dictionary),
                    isBanned: try Response.extract(param: "isBanned", from: dictionary),
                    accessLevel: try Response.extract(param: "accessLevel", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("isBanned"): try self.encode(self.isBanned),
                    self.getDictionaryKey("accessLevel"): try self.encode(self.accessLevel),
                ]
            }
        }
    }

    struct UserInfoInternal: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.User

        public static let URI = "UserInfoInternal"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeUserInfoInternalContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeUserInfoInternalContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "ID": "a",
            ]

            public var ID: String

            public init(
                ID: String
            ) {
                self.ID = ID
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "ID": [],
                ]

                var _ID: String = String()

                do {
                    do {
                        _ID = try Request.extract(param: "ID", from: dictionary)

                        if let error = Validation.UUID().validate(_ID, requestInfo.locale) {
                            validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["ID"]!.append(eventLoop.makeSucceededFuture(("ID", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            ID: _ID
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    ID: try Request.extract(param: "ID", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("ID"): try self.encode(self.ID),
                ]
            }
        }
    }

    struct Authenticate: Contract {
        public typealias ParentService = Services.Author

        public static let URI = "Authenticate"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeAuthenticateContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeAuthenticateContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "portal": "b",
                "token": "c",
            ]

            public let portal: String
            public let token: String

            public init(
                portal: String,
                token: String
            ) {
                self.portal = portal
                self.token = token
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "portal": [],
                    "token": [],
                ]

                var _portal: String = String()
                var _token: String = String()

                do {
                    do {
                        _portal = try Request.extract(param: "portal", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["portal"]!.append(eventLoop.makeSucceededFuture(("portal", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            portal: _portal,
                            token: _token
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    portal: try Request.extract(param: "portal", from: dictionary),
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("portal"): try self.encode(self.portal),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }
        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "IDUser": "b",
            ]

            public let IDUser: String?

            public init(
                IDUser: String? = nil
            ) {
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Response> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "IDUser": [],
                ]

                var _IDUser: String?

                do {
                    do {
                        _IDUser = try Response.extract(param: "IDUser", from: dictionary, isOptional: true)
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDUser"]!.append(eventLoop.makeSucceededFuture(("IDUser", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            IDUser: _IDUser
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDUser: try Response.extract(param: "IDUser", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }
        }
    }

    struct ChangePassword: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ChangePassword"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeChangePasswordContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeChangePasswordContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "token": "b",
                "password1": "c",
                "password2": "d",
            ]

            public let token: String
            public let password1: String
            public let password2: String

            public init(
                token: String,
                password1: String,
                password2: String
            ) {
                self.token = token
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "token": [],
                    "password1": [],
                    "password2": [],
                ]

                var _token: String = String()
                var _password1: String = String()
                var _password2: String = String()

                do {
                    do {
                        _token = try Request.extract(param: "token", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["token"]!.append(eventLoop.makeSucceededFuture(("token", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password1 = try Request.extract(param: "password1", from: dictionary)

                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }

                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password2 = try Request.extract(param: "password2", from: dictionary)

                        if let error = Validation.Identical(right: _password1, message: "Passwords must match").validate(_password2, requestInfo.locale) {
                            validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            token: _token,
                            password1: _password1,
                            password2: _password2
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }
        }
    }

    struct ValidateEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "ValidateEmail"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeValidateEmailContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeValidateEmailContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "node": "b",
                "validationToken": "c",
                "IDUser": "d",
            ]

            public let node: String
            public let validationToken: String
            public var IDUser: String

            public init(
                node: String,
                validationToken: String,
                IDUser: String
            ) {
                self.node = node
                self.validationToken = validationToken
                self.IDUser = IDUser
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "node": [],
                    "validationToken": [],
                    "IDUser": [],
                ]

                var _node: String = String()
                var _validationToken: String = String()
                var _IDUser: String = String()

                do {
                    do {
                        _node = try Request.extract(param: "node", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["node"]!.append(eventLoop.makeSucceededFuture(("node", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _validationToken = try Request.extract(param: "validationToken", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["validationToken"]!.append(eventLoop.makeSucceededFuture(("validationToken", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _IDUser = try Request.extract(param: "IDUser", from: dictionary)

                        if let error = Validation.UUID().validate(_IDUser, requestInfo.locale) {
                            validatorFutures["IDUser"]!.append(eventLoop.makeSucceededFuture(("IDUser", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDUser"]!.append(eventLoop.makeSucceededFuture(("IDUser", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            node: _node,
                            validationToken: _validationToken,
                            IDUser: _IDUser
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    node: try Request.extract(param: "node", from: dictionary),
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("node"): try self.encode(self.node),
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }
        }
    }

    struct ResendValidationEmail: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ResendValidationEmail"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeResendValidationEmailContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeResendValidationEmailContract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "email": "b",
                "recaptchaToken": "c",
            ]

            public let email: String
            public let recaptchaToken: String

            public init(
                email: String,
                recaptchaToken: String
            ) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "email": [],
                    "recaptchaToken": [],
                ]

                var _email: String = String()
                var _recaptchaToken: String = String()

                do {
                    do {
                        _email = try Request.extract(param: "email", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["email"]!.append(eventLoop.makeSucceededFuture(("email", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _recaptchaToken = try Request.extract(param: "recaptchaToken", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["recaptchaToken"]!.append(eventLoop.makeSucceededFuture(("recaptchaToken", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            email: _email,
                            recaptchaToken: _recaptchaToken
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }
        }
    }

    struct ResetPasswordStep1: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "ResetPasswordStep1"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeResetPasswordStep1Contract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeResetPasswordStep1Contract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "email": "b",
                "recaptchaToken": "c",
            ]

            public let email: String
            public let recaptchaToken: String

            public init(
                email: String,
                recaptchaToken: String
            ) {
                self.email = email
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "email": [],
                    "recaptchaToken": [],
                ]

                var _email: String = String()
                var _recaptchaToken: String = String()

                do {
                    do {
                        _email = try Request.extract(param: "email", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["email"]!.append(eventLoop.makeSucceededFuture(("email", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _recaptchaToken = try Request.extract(param: "recaptchaToken", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["recaptchaToken"]!.append(eventLoop.makeSucceededFuture(("recaptchaToken", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            email: _email,
                            recaptchaToken: _recaptchaToken
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }
        }
    }

    struct ResetPasswordStep2: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = Services.Shared.LoginResponse

        public static let URI = "ResetPasswordStep2"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeResetPasswordStep2Contract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeResetPasswordStep2Contract(callback)
        }

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [
                "validationToken": "b",
                "IDUser": "c",
                "password1": "d",
                "password2": "e",
            ]

            public let validationToken: String
            public var IDUser: String
            public let password1: String
            public let password2: String

            public init(
                validationToken: String,
                IDUser: String,
                password1: String,
                password2: String
            ) {
                self.validationToken = validationToken
                self.IDUser = IDUser
                self.password1 = password1
                self.password2 = password2
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "validationToken": [],
                    "IDUser": [],
                    "password1": [],
                    "password2": [],
                ]

                var _validationToken: String = String()
                var _IDUser: String = String()
                var _password1: String = String()
                var _password2: String = String()

                do {
                    do {
                        _validationToken = try Request.extract(param: "validationToken", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["validationToken"]!.append(eventLoop.makeSucceededFuture(("validationToken", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _IDUser = try Request.extract(param: "IDUser", from: dictionary)

                        if let error = Validation.UUID().validate(_IDUser, requestInfo.locale) {
                            validatorFutures["IDUser"]!.append(eventLoop.makeSucceededFuture(("IDUser", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["IDUser"]!.append(eventLoop.makeSucceededFuture(("IDUser", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password1 = try Request.extract(param: "password1", from: dictionary)

                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }

                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password2 = try Request.extract(param: "password2", from: dictionary)

                        if let error = Validation.Identical(right: _password1, message: "Passwords must match").validate(_password2, requestInfo.locale) {
                            validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            validationToken: _validationToken,
                            IDUser: _IDUser,
                            password1: _password1,
                            password2: _password2
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    validationToken: try Request.extract(param: "validationToken", from: dictionary),
                    IDUser: try Request.extract(param: "IDUser", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("validationToken"): try self.encode(self.validationToken),
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                ]
            }
        }
    }

    struct InternalSignup: Contract {
        public typealias ParentService = Services.Author

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "InternalSignup"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeInternalSignupContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeInternalSignupContract(callback)
        }

        public final class Request: ContractEntity {
            public enum CallbackValidatorUsernameAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenUsernameAlreadyExists = "User with given username already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .UserWithGivenUsernameAlreadyExists: return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public enum CallbackValidatorEmailAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenEmailAlreadyExists = "User with given email already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                    case .UserWithGivenEmailAlreadyExists: return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public static let keyDictionary: [String: String] = [
                "username": "b",
                "email": "c",
                "password1": "d",
                "password2": "e",
                "sex": "f",
                "language": "g",
                "recaptchaToken": "h",
                "ip": "i",
                "userAgent": "j",
                "country": "k",
            ]

            public let username: String
            public let email: String
            public let password1: String
            public let password2: String
            public let sex: String
            public let language: String
            public let recaptchaToken: String
            public let ip: String
            public let userAgent: String
            public let country: String

            private static var validatorUsernameClosure: Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback?
            private static var validatorEmailClosure: Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback?

            public init(
                username: String,
                email: String,
                password1: String,
                password2: String,
                sex: String,
                language: String,
                recaptchaToken: String,
                ip: String,
                userAgent: String,
                country: String
            ) {
                self.username = username
                self.email = email
                self.password1 = password1
                self.password2 = password2
                self.sex = sex
                self.language = language
                self.recaptchaToken = recaptchaToken
                self.ip = ip
                self.userAgent = userAgent
                self.country = country
            }

            public static func initWithValidation(from dictionary: Entita.Dict, requestInfo: LGNCore.RequestInfo) -> Future<Request> {
                let eventLoop = requestInfo.eventLoop

                var validatorFutures: [String: [Future<(String, ValidatorError?)>]] = [
                    "username": [],
                    "email": [],
                    "password1": [],
                    "password2": [],
                    "sex": [],
                    "language": [],
                    "recaptchaToken": [],
                    "ip": [],
                    "userAgent": [],
                    "country": [],
                ]

                var _username: String = String()
                var _email: String = String()
                var _password1: String = String()
                var _password2: String = String()
                var _sex: String = String()
                var _language: String = String()
                var _recaptchaToken: String = String()
                var _ip: String = String()
                var _userAgent: String = String()
                var _country: String = String()

                do {
                    do {
                        _username = try Request.extract(param: "username", from: dictionary)

                        if let error = Validation.Regexp(pattern: "^[a-zA-Zа-яА-Я0-9_\\- ]+$", message: "Username must only consist of letters, numbers and underscores").validate(_username, requestInfo.locale) {
                            validatorFutures["username"]!.append(eventLoop.makeSucceededFuture(("username", error)))
                        }

                        if let error = Validation.Length.Min(length: 3).validate(_username, requestInfo.locale) {
                            validatorFutures["username"]!.append(eventLoop.makeSucceededFuture(("username", error)))
                        }

                        if let error = Validation.Length.Max(length: 24).validate(_username, requestInfo.locale) {
                            validatorFutures["username"]!.append(eventLoop.makeSucceededFuture(("username", error)))
                        }

                        if let validatorUsernameClosure = self.validatorUsernameClosure {
                            validatorFutures["username"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>(callback: validatorUsernameClosure).validate(
                                    _username,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("username", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["username"]!.append(eventLoop.makeSucceededFuture(("username", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _email = try Request.extract(param: "email", from: dictionary)

                        if let error = Validation.Regexp(pattern: "^.+@.+\\..+$", message: "Invalid email format").validate(_email, requestInfo.locale) {
                            validatorFutures["email"]!.append(eventLoop.makeSucceededFuture(("email", error)))
                        }

                        if let validatorEmailClosure = self.validatorEmailClosure {
                            validatorFutures["email"]!.append(
                                Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>(callback: validatorEmailClosure).validate(
                                    _email,
                                    requestInfo.locale,
                                    on: eventLoop
                                ).map { ("email", $0) }
                            )
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["email"]!.append(eventLoop.makeSucceededFuture(("email", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password1 = try Request.extract(param: "password1", from: dictionary)

                        if let error = Validation.Length.Min(length: 6, message: "Password must be at least {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }

                        if let error = Validation.Length.Max(length: 64, message: "Password must be less than {Length} characters long").validate(_password1, requestInfo.locale) {
                            validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password1"]!.append(eventLoop.makeSucceededFuture(("password1", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _password2 = try Request.extract(param: "password2", from: dictionary)

                        if let error = Validation.Identical(right: _password1, message: "Passwords must match").validate(_password2, requestInfo.locale) {
                            validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["password2"]!.append(eventLoop.makeSucceededFuture(("password2", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _sex = try Request.extract(param: "sex", from: dictionary)

                        if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(_sex, requestInfo.locale) {
                            validatorFutures["sex"]!.append(eventLoop.makeSucceededFuture(("sex", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["sex"]!.append(eventLoop.makeSucceededFuture(("sex", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _language = try Request.extract(param: "language", from: dictionary)

                        if let error = Validation.In(allowedValues: ["en", "ru"]).validate(_language, requestInfo.locale) {
                            validatorFutures["language"]!.append(eventLoop.makeSucceededFuture(("language", error)))
                        }
                    } catch Entita.E.ExtractError {
                        validatorFutures["language"]!.append(eventLoop.makeSucceededFuture(("language", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _recaptchaToken = try Request.extract(param: "recaptchaToken", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["recaptchaToken"]!.append(eventLoop.makeSucceededFuture(("recaptchaToken", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _ip = try Request.extract(param: "ip", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["ip"]!.append(eventLoop.makeSucceededFuture(("ip", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _userAgent = try Request.extract(param: "userAgent", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["userAgent"]!.append(eventLoop.makeSucceededFuture(("userAgent", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                    do {
                        _country = try Request.extract(param: "country", from: dictionary)
                    } catch Entita.E.ExtractError {
                        validatorFutures["country"]!.append(eventLoop.makeSucceededFuture(("country", Validation.Error.MissingValue(requestInfo.locale))))
                    }
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                return self
                    .reduce(validators: validatorFutures, on: eventLoop)
                    .flatMapThrowing { errors in
                        guard errors.count == 0 else {
                            throw LGNC.E.DecodeError(errors)
                        }
                        return self.init(
                            username: _username,
                            email: _email,
                            password1: _password1,
                            password2: _password2,
                            sex: _sex,
                            language: _language,
                            recaptchaToken: _recaptchaToken,
                            ip: _ip,
                            userAgent: _userAgent,
                            country: _country
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    username: try Request.extract(param: "username", from: dictionary),
                    email: try Request.extract(param: "email", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary),
                    sex: try Request.extract(param: "sex", from: dictionary),
                    language: try Request.extract(param: "language", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary),
                    ip: try Request.extract(param: "ip", from: dictionary),
                    userAgent: try Request.extract(param: "userAgent", from: dictionary),
                    country: try Request.extract(param: "country", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                return [
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("language"): try self.encode(self.language),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                    self.getDictionaryKey("ip"): try self.encode(self.ip),
                    self.getDictionaryKey("userAgent"): try self.encode(self.userAgent),
                    self.getDictionaryKey("country"): try self.encode(self.country),
                ]
            }

            public static func validateUsername(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback
            ) {
                self.validatorUsernameClosure = callback
            }

            public static func validateEmail(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback
            ) {
                self.validatorEmailClosure = callback
            }
        }
    }

    struct Signup: Contract {
        public typealias ParentService = Services.Author

        public typealias Request = Services.Shared.UserSignupRequest
        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Signup"
        static let visibility: ContractVisibility = .Private
        static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        static let contentTypes: [Services.ContentType] = Services.ContentType.all

        public static func guarantee(_ callback: @escaping Callback) {
            Services.Author.guaranteeSignupContract(callback)
        }

        public static func guarantee(_ callback: @escaping NonFutureCallback) {
            Services.Author.guaranteeSignupContract(callback)
        }
    }
}
